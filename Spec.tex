\documentclass{article}
\usepackage{enumitem}
\usepackage{zed}
\usepackage{verbatim}
\usepackage{framed}

\def\spec#1{{\tt #1}}
\def\req#1{{\sf {{\it #1}} }}
\def\bnf#1{{\scriptsize {{#1}} }}


\raggedbottom
\include{uml_style}

\title{A Declarative Semantics for SNOMED~CT Expression Constraints}

\begin{document}
\maketitle
\tableofcontents

\section{Axiomatic Data Types}
\subsection{Atomic Data Types}
This section identifies the atomic data types that are assumed for the rest of this specification, specifically:
\begin{itemize}[noitemsep]
\item \textbf{SCTID} -- a SNOMED CT identifier
\item \textbf{TERM} --  a  fully specified name, preferred term or synonym for a SNOMED CT Concept
\item \textbf{REAL} --  a real number
\item \textbf{STRING} -- a string literal
\item \textbf{GROUP} -- a role group identifier
\item \textbf{$\nat$} -- a non-negative integer
\item \textbf{$\num$} -- an integer
\end{itemize}

\begin{zed}
[SCTID, TERM, REAL, STRING, GROUP] 
\end{zed}


We will also need to recognize some well known identifiers: the $is\_a$ attribute, the $zero\_group$ and  $attribute\_concept$, the parent of all attributes
\begin{axdef}
is\_a : SCTID \\
zero\_group : GROUP \\
attribute\_concept : SCTID \\
refset\_concept : SCTID
\end{axdef}

\subsection{Composite Data Types}
While we can't fully specify the behavior of the concrete data types portion of the specification at this point, it is still useful 
to spell out the anticipated behavior on an abstract level.
\begin{itemize}[noitemsep,nolistsep]
\item \textbf{CONCRETEVALUE} -- a string, integer or real literal
\item \textbf{TARGET} -- the target of a relationship that is either an $SCTID$ or a $CONCRETEVALUE$
\end{itemize}
\begin{zed}
CONCRETEVALUE ::= string \ldata STRING \rdata | integer \ldata \num \rdata | real \ldata REAL \rdata \\
TARGET ::= object \ldata SCTID \rdata | concrete \ldata CONCRETEVALUE \rdata
\end{zed}

\section{The Substrate}
A substrate represents the context of an interpretation.  
\subsection{Substrate Components}
\paragraph{Quad}
Relationships in the substrate are represented a 4 element tuples or ``quads'' which consist of a source, attribute, target and role group identifier.  The $is\_a$ attribute may
only appear in the zero group, and the target of an $is\_a$ attribute must be a $SCTID$ (not a $CONCRETEVALUE$)

\begin{schema}{Quad}
   s : SCTID \\
   a : SCTID \\
   t : TARGET \\
   g : GROUP
\where
   a = is\_a \implies (g = zero\_group \land object \inv t \in SCTID)
\end{schema}




\subsection{Substrate}
A substrate consists of:

\begin{itemize}[noitemsep,nolistsep]
\item{\textbf{concepts}} The set of $SCTID$s (concepts) that are considered valid in the context of the substrate.  \req{References to any $SCTID$ that is
not a member of $concepts$ MUST be treated as an error.}
\item{\textbf{relationships}} A set of relationship quads (source, attribute, target, group)
\item{\textbf{parentsOf}}  A function from an SCTID to its asserted and inferred parents
\item{\textbf{equivalent\_concepts}} A function from an SCTID to the set of SCTID's that have been determined to be equivalent to it. 
 \item{\textbf{refsets}} The reference sets within the context of the substrate whose members are members are concept identifiers (i.e. are in $concepts$).  While not formally spelled out in this specification, it is assumed that the typical reference set function would be returning a subset of the $refsetId$/$referencedComponentId$ tuples represented in one or more RF2 Refset Distribution tables.
\end{itemize}
\paragraph{}

The following functions can be computed from the basic set above
\begin{itemize}[noitemsep,nolistsep]
\item{\textbf{childrenOf}} The inverse of the parentsOf function
\item{\textbf{descendants}} The transitive closure of the childrenOf function
\item{\textbf{ancestors}} The transitive closure of the parentsOf function
\item{\textbf{attributeIds}} The descendantsOf the attribute\_concept, including equivalents
\item{\textbf{refsetsIds}} The descendants of the refset\_concept, including equivalents
\end{itemize}
\paragraph{}
The formal definition of substrate follows, where c and r are given and the remainder are derived.  The expressions below assert that:
\begin{enumerate}[noitemsep,nolistsep]
\item All sources, attributes and SCTID targets of $relationships$ are included in the substrate $concepts$ list.
\item There is a $parentsOf$ entry for every concept in the substrate $concepts$ list.
\item Every sctid in the range of the $parentsOf$ function is in the substrate $concepts$ list.
\item Every $is\_a$ relationship entry is represented in the $parentsOf$ function.  (Note that the reverse isn't necessarily true).
\item There is an $equivalent\_concepts$ assertion for every substrate concept.
\item The $equivalent\_concepts$ function is reflexive (i.e. every concept is equivalent to itself)
\item If two concepts (c2 and c2) are equivalent, then they:
\begin{itemize}[noitemsep,nolistsep]
\item Have the same parents
\item Appear the subject, attribute and object of the same set of relationships
\item Appear in the domain of the same set of refsets
\item Both appear in the range of any refset that one appears in
\end{itemize}
\item Every refset is a substrate $concepts$
\item Every member of a refset is a substrate $concept$
\item $childrenOf$ is the inverse of $parentsOf$, where any concept that isn't a parent has no children.
\item $descendants$ is the transitive closure of the $childrenOf$ function
\item $ancestors$ is the transitive closure of the $parentsOf$ function
\item No concept can be its own ancestor (or, by inference, descendant)
\item Every $attributeId$ is a substrate $concept$
\item Every $refsetId$ is a substrate $concept$
\end{enumerate}
\begin{schema}{Substrate}
   concepts : \power SCTID \\
   relationships : \power Quad  \\
   parentsOf : SCTID \pfun \power SCTID \\
   equivalent\_concepts : SCTID \pfun \power SCTID \\
   refsets : SCTID \pfun \power SCTID
\also
   childrenOf : SCTID \pfun \power SCTID \\
   descendants : SCTID \pfun \power SCTID \\
   ancestors : SCTID \pfun \power SCTID \\
   attributeIds : \power SCTID \\
   refsetIds : \power SCTID
\where
   \forall rel : relationships @  rel.s \in concepts \land rel.a \in concepts \land \\
\t2 (object \inv rel.t \in SCTID \implies object \inv rel.t \in concepts)
\also
   \dom parentsOf = concepts \\
   \bigcup (\ran parentsOf) \subseteq concepts
\also
   \forall r : relationships @ r.a = is\_a \implies (object \inv r.t) \in parentsOf~r.a
\also
   \dom equivalent\_concepts = concepts \\
  \forall c : concepts @ c \in equivalent\_concepts~c \\
  \forall c1, c2 : concepts | c2 \in (equivalent\_concepts~c1) @ \\
\t2 parentsOf ~ c1 = parentsOf ~ c2 \land \\
\t2 \{r : relationships | r.s = c1\} = \{r : relationships | r.s = c2\} \land \\
\t2 \{r : relationships | r.a = c1\} = \{r : relationships | r.a = c2\} \land \\
\t2 \{r : relationships | object \inv r.t = c1\} = \{r : relationships | object \inv r.t = c2\} \land \\
\t2 c1 \in \dom refsets \iff c2 \in \dom refsets \land \\
\t2 c1 \in \dom refsets \implies refsets~c1 = refsets~c2 \land \\
\t2 (\forall rsd : \ran refsets @ c1 \in rsd \iff c2 \in rsd)
\also
   \dom refsets \subseteq concepts \\
   \bigcup (\ran refsets) \subseteq concepts
\also
    \dom childrenOf = concepts \\
    \forall s, t : concepts @ t \in parentsOf~s \iff s \in childrenOf~t  \\
    \forall c : concepts | c \notin \bigcup (\ran childrenOf) @ childrenOf~c = \emptyset 
\also
   \forall s : concepts @ \\
\t2 descendants~s = childrenOf~ s \cup \bigcup \{t : childrenOf~ s @ descendants~t\} \\
   \forall t : concepts @ \\
\t2 ancestors~t = parentsOf~ t \cup \bigcup \{s : parentsOf~ t @ ancestors~s\} \\
   \forall t : concepts @ t \notin ancestors~t
\also
   attributeIds \subseteq concepts \\
   refsetIds \subseteq concepts
\end{schema}
\subsubsection{Strict and Permissive Substrates}
Implementations may choose to implement ``strict'' substrates, where additional rules apply or ``permissive'' substrates where rules are relaxed.
\subsubsection{Strict Substrate}
A \textbf{strict\_substrate} is a substrate where:
\begin{itemize}[noitemsep,nolistsep]
\item There is at least one $SCTID$ that is not substrate concept 
\item Every $attributeId$ must be a descendant of $attribute\_concept$
\item Every $refsetId$ must be a descendant of $refset\_concept$
\item $relationship$ attributes must be $attributeId$s
\item $refset$ domains must be $refsetId$s 
\end{itemize}

\begin{schema}{strict\_substrate}
    Substrate
 \where
     concepts \subset SCTID \\
     attributeIds =  descendants~attribute\_concept \\
     \forall r: relationships @ r.a \in attributeIds
\also
    refsetIds = descendants~refset\_concept \\
    \dom refsets \subseteq refsetIds
 \end{schema}
 
 \subsubsection{Permissive Substrate}
 A permissive substrate is a substrate where every query will return some result -- all $SCTID's$ are considered valid.
 
 This includes the following rules:
 \begin{enumerate}[noitemsep,nolistsep]
 \item Every possible $SCTID$ is a substrate concept, attribute and a valid refset
 \item The refset function will return a (possibly empty) set of results for any refuted
 \end{enumerate}
 
 
 \begin{schema}{permissive\_substrate}
    Substrate
\where
    concepts = SCTID \land attributeIds = concepts \land refsetIds = concepts 
\end{schema}
   


\section{SCTIDS or Error Return}
The result of applying a query against a substrate is either a (possibly empty) set of SCTID's or an $ERROR$.  An $ERROR$ occurs when:
\begin{itemize}[noitemsep,nolistsep]
\item The interpretation of a conceptId is not a substrate $concept$
\item The interpretation of a relationship attribute is not a substrate $attributeId$
\item The interpretation of a reset is not a substrate $refsetId$
\end{itemize}


\begin{zed}  
ERROR ::= unknownConceptReference | unknownAttributeId | unknownRefsetId 
\also
Sctids\_or\_Error ::= ok \ldata \power SCTID \rdata | error \ldata ERROR \rdata 
\end{zed}

\section{Interpretation of Expression Constraints}
This section defines the interpretation of all language constructs that are interpreted in terms of other language constructs.  Each interpretation that follows begins with a simplified version
of the language construct in the specification.  It then formally specifies the constructs that are used in the interpretation, followed by the interpretation itself. We start with the definition 
of $expressionConstraint$, which, once interpreted, returns either a set of SCTIDs or an error condition.
\subsection{expressionConstraint}
\begin{framed}
\noindent
\bnf{expressionConstraint = ws ( refinedExpressionConstraint / unrefinedExpressionConstraint ) ws}
\end{framed}

\spec{expressionConstraint} takes either a \spec{refinedExpressionConstraint} or \\ \spec{unrefinedExpressionConstraint} and returns its interpretation as either a set of SCTIDs or an error condition.
\begin{zed}
expressionConstraint ::= \\
\t2 expcons\_refined \ldata refinedExpressionConstraint \rdata | \\
\t2 expcons\_unrefined \ldata unrefinedExpressionConstraint \rdata \\
\end{zed}


\begin{gendef}
   i\_expressionConstraint : \\
\t2 Substrate \fun expressionConstraint \fun Sctids\_or\_Error
\where
   \forall ss: Substrate; ec: expressionConstraint @ i\_expressionConstraint~ss~ec = \\
   \IF ec \in \ran expcons\_refined  \\
\t1 \THEN i\_refinedExpressionConstraint~ss~(expcons\_refined \inv ec) \\
   \ELSE i\_unrefinedExpressionConstraint~ss~(expcons\_unrefined \inv ec) 
\end{gendef}

\subsubsection{unrefinedExpressionConstraint}
The interpretation of an \spec{unrefinedExpressionConstraint} is either the interpretation of a \spec{compoundExpressionConstraint} or a \spec{simpleExpressionConstraint}

\begin{framed}
\noindent
\bnf{unrefinedExpressionConstraint = compoundExpressionConstraint / simpleExpressionConstraint}
\end{framed}

\begin{zed}
unrefinedExpressionConstraint ::= \\
\t2 unrefined\_compound \ldata compoundExpressionConstraint \rdata | \\
\t2 unrefined\_simple \ldata simpleExpressionConstraint \rdata
\end{zed}
\begin{gendef}
   i\_unrefinedExpressionConstraint : \\
\t2 Substrate \fun unrefinedExpressionConstraint \fun Sctids\_or\_Error
\where
   \forall ss : Substrate; uec : unrefinedExpressionConstraint @  \\
   i\_unrefinedExpressionConstraint~ss~uec = \\
   \IF ucec \in \ran unrefined\_compound \\
\t1 \THEN i\_compoundExpressionConstraint~ss~(unrefined\_compound \inv uec) \\
\ELSE  i\_simpleExpressionConstraint~ss~(unrefined\_simple \inv uec) 
\end{gendef}

\subsubsection{refinedExpressionConstraint}
\begin{framed}
\noindent
\bnf{refinedExpressionConstraint = unrefinedExpressionConstraint ws ":" ws refinement / "(" ws refinedExpressionConstraint ws ")"}
\end{framed}

The interpretation of \spec{refinedExpressionConstraint} is the intersection of the interpretation of
the \spec{unrefinedExpressionConstraint} and the \spec{refinement}, both of which return a set of SCTID's or
an error.  The second production defines \spec{refinedExpressionConstraint} in terms of itself and has no impact on the results.

\begin{zed}
refinedExpressionConstraint == \\
\t2 unrefinedExpressionConstraint \cross refinement \\
\end{zed}

\begin{gendef}
   i\_refinedExpressionConstraint : \\
\t1 Substrate \fun refinedExpressionConstraint \fun Sctids\_or\_Error
\where
   \forall ss : Substrate; rec : refinedExpressionConstraint @ \\
   i\_refinedExpressionConstraint~ss~rec = \\
\t1 intersect~(i\_unrefinedExpressionConstraint~ss~(first~rec)) (i\_refinement~ss~(second~rec))
\end{gendef}

\begin{gendef}
   i\_refinedExpressionConstraint : \\
\t1 Substrate \fun refinedExpressionConstraint \fun Sctids\_or\_Error
\end{gendef}


\subsubsection{simpleExpressionConstraint}
The interpretation of  \spec{simpleExpressionConstraint} is the application of an optional constraint 
operator to the interpretation of \spec{focusConcept}, which returns a set of SCTID's or an error.
The interpretation of an error is the error.


\begin{framed}
\noindent
\bnf{simpleExpressionConstraint =  [constraintOperator ws] focusConcept} \\
bnf{constraintOperator = descendantOrSelfOf / descendantOf /  ancestorOrSelfOf / ancestorOf}
\end{framed}


\begin{zed}
simpleExpressionConstraint == \optional[constraintOperator] \cross focusConcept \\
constraintOperator ::= descendantsOrSelfOf | descendantOf | ancestorOrSelfOf | ancestorOf
\end{zed} 

\begin{gendef}
   i\_simpleExpressionConstraint : \\
\t2 Substrate \fun simpleExpressionConstraint \fun Sctids\_or\_Error
\where
   \forall ss : Substrate; sec : simpleExpressionConstraint @ \\
i\_simpleExpressionConstraint~ss~sec =  \\
\t2 i\_constraintOperator~ss~(first~sec)~(i\_focusConcept~ss~(second~sec))
\end{gendef}


\subsubsection{compoundExpressionConstraint}
The interpretation of a $compoundExpressionConstraint$ is the interpretation of its corresponding component.
\begin{framed}
\noindent
\bnf{compoundExpressionConstraint = conjunctionExpressionConstraint / 
	disjunctionExpressionConstraint / exclusionExpressionConstraint / 
	"(" ws compoundExpressionConstraint ws ")"}
\end{framed}

\begin{zed}
compoundExpressionConstraint ::= \\
\t2 compound\_conj \ldata conjunctionExpressionConstraint \rdata | \\
\t2 compound\_disj \ldata disjunctionExpressionConstraint \rdata | \\
\t2 compound\_excl \ldata exclusionExpressionConstraint \rdata 
\end{zed}

\begin{gendef}
   i\_compoundExpressionConstraint : \\
\t2 Substrate \fun compoundExpressionConstraint \fun Sctids\_or\_Error
\where
  \forall ss : Substrate; cec : compoundExpressionConstraint @ \\
 i\_compoundExpressionConstraint~ss~cec = \\
   \IF cec \in \ran compound\_conj \\
\t1 \THEN i\_conjunctionExpressionConstraint~ss~(compound\_conj \inv cec) \\
    \ELSE \IF cec \in\ran compound\_disj \\
\t1 \THEN i\_disjunctionExpressionConstraint~ss~(compound\_disj \inv cec) \\
    \ELSE i\_exclusionExpressionConstraint~ss~(compound\_excl \inv cec) 
\end{gendef}

The signature below is used because the definition of \spec{compountExpressionConstraint} is recursive
\begin{gendef}
   i\_compoundExpressionConstraint' : \\
\t2 Substrate \fun compoundExpressionConstraint \fun Sctids\_or\_Error
\end{gendef}


\subsubsection{conjunctionExpressionConstraint}
\spec{conjunctionExpressionConstraint} is interpreted the conjunction (intersection) of the interpretation of two or more
\spec{subExpressionConstraints}/  The \spec{conjunction} aspect is ignored because there is no other choice
\begin{framed}
\noindent
\bnf{conjunctionExpressionConstraint = subExpressionConstraint 1*(ws conjunction ws subExpressionConstraint)}
\end{framed}

\begin{zed}
conjunctionExpressionConstraint == \\
\t2 subExpressionConstraint \cross \seq_1(subExpressionConstraint)
\end{zed}

Apply the intersection operator to the interpretation of each  subExpressionConstraint

\begin{gendef}
    i\_conjunctionExpressionConstraint : \\
\t1 Substrate \fun conjunctionExpressionConstraint \fun Sctids\_or\_Error
\where
   \forall ss : Substrate;  cecr : conjunctionExpressionConstraint @ \\
i\_conjunctionExpressionConstraint~ss~cecr = \\
\t1 applyToSequence~ss~i\_subExpressionConstraint~intersect~cecr
\end{gendef}

\subsubsection{disjunctionExpressionConstraint}
\spec{disjunctionExpressionConstraint} is interpreted the disjunction (union) of the interpretation of two or more
\spec{subExpressionConstraints}. The \spec{disjunction} element is ignored because there is no other choice.
\begin{framed}
\noindent
\bnf{disjunctionExpressionConstraint = subExpressionConstraint 1*(ws disjunction ws subExpressionConstraint)}
\end{framed}

\begin{zed}
disjunctionExpressionConstraint == \\
\t2 subExpressionConstraint \cross \seq_1(subExpressionConstraint)
\end{zed}

Apply the union operator to the interpretation of each  subExpressionConstraint

\begin{gendef}
    i\_disjunctionExpressionConstraint : \\
\t1 Substrate \fun disjunctionExpressionConstraint \fun Sctids\_or\_Error
\where
   \forall ss : Substrate;  decr : disjunctionExpressionConstraint @ \\
i\_disjunctionExpressionConstraint~ss~decr = \\
\t1 applyToSequence~ss~i\_subExpressionConstraint~union~decr
\end{gendef}




\subsubsection{exclusionExpressionConstraint}
The interpretation \spec{exclusionExpressionConstraint} removes the interpretation of the second \spec{exclusionExpressionConstraint} from
the interpretation of the first.  Errors are propagated.

\begin{framed}
\noindent
\bnf{exclusionExpressionConstraint = subExpressionConstraint ws exclusion ws subExpressionConstraint}
\end{framed}

\begin{zed}
exclusionExpressionConstraint == \\ 
\t2subExpressionConstraint \cross subExpressionConstraint
\end{zed}

\begin{gendef}
    i\_exclusionExpressionConstraint : \\
\t2 Substrate \fun exclusionExpressionConstraint \fun Sctids\_or\_Error
\where
   \forall ss : Substrate; ecr : exclusionExpressionConstraint @ \\
i\_exclusionExpressionConstraint~ss~ecr = \\
\t1~ minus~~ (i\_subExpressionConstraint~ss~(first~ecr)) (i\_subExpressionConstraint~ss~(second~ecr))
\end{gendef}

\subsubsection{subExpressionConstraint}
$subExpressionConstraint$ is interpreted as the interpretation of either a $simpleExpressionConstraint$
or a $compoundExpressionConstraint$
\begin{framed}
\noindent
\bnf{subExpressionConstraint = simpleExpressionConstraint / "(" ws (compoundExpressionConstraint / refinedExpressionConstraint)  ws ")"}
\end{framed}

\begin{zed}
subExpressionConstraint ::= \\
\t1 subExpr\_simple \ldata simpleExpressionConstraint \rdata | \\
\t1 subExpr\_compound \ldata compoundExpressionConstraint \rdata | \\
\t1 subExpr\_refined \ldata refinedExpressionConstraint \rdata
\end{zed}

\begin{gendef}
   i\_subExpressionConstraint : \\
\t2 Substrate \fun subExpressionConstraint \fun Sctids\_or\_Error
\where
   \forall ss : Substrate; sec : subExpressionConstraint @ \\
i\_subExpressionConstraint~ss~sec = \\
   \IF sec \in \ran subExpr\_simple \\
\t1 \THEN i\_simpleExpressionConstraint~ss~(subExpr\_simple \inv sec) \\
    \ELSE \IF sec \in \ran subExpr\_compound \\
\t1 \THEN i\_compoundExpressionConstraint~ss~(subExpr\_compound \inv sec) \\
    \ELSE i\_refinedExpressionConstraint~ss~(subExpr\_refined \inv sec) 
\end{gendef}

\subsection{refinement}
The interpretation of \spec{refinement} is the interpretation of the \spec{subRefinement}, \spec{conjunctionGroup} or \spec{disjunctionGroup}
\begin{framed}
\noindent
\bnf{refinement = subRefinement / conjunctionGroup / disjunctionGroup}
\end{framed}

\begin{zed}
refinement ::= \\
\t1 refine\_subrefine \ldata subRefinement \rdata | \\
\t1 refine\_conjg \ldata conjunctionGroup \rdata | \\
\t1 refine\_disjg \ldata disjunctionGroup \rdata
\end{zed}

\begin{gendef}
   i\_refinement : Substrate \fun refinement \fun Sctids\_or\_Error
\where
   \forall ss : Substrate; rfnment : refinement @ i\_refinement = \\
   \IF rfnment \in \ran refine\_subrefine \\
\t1 \THEN i\_subRefinement~ss~(refine\_subrefine \inv refinement) \\
   \ELSE \IF rfnment \in \ran refine\_conjg \\
\t1 \THEN i\_conjunctionGroup~ss~(refine\_conjg \inv refinement) \\
   \ELSE i\_disjunctionGroup~ss~(refine\_disjg \inv refinement)
\end{gendef}

\subsubsection{conjunctionGroup}
\begin{framed}
\noindent
\bnf{conjunctionGroup = subRefinement 1*(conjunction subRefinement)}
\end{framed}

\begin{zed}
conjunctionGroup == \\
\t2 subRefinement \cross \seq_1(subRefinement)
\end{zed}

Apply the intersect operator to the interpretation of each  subRefinement

\begin{gendef}
    i\_conjunctionGroup : \\
\t1 Substrate \fun conjunctionGroup \fun Sctids\_or\_Error
\where
   \forall ss : Substrate;  conjg : conjunctionGroup @ \\
i\_conjunctionGroup~ss~conjg = \\
\t1 applyToSequence~ss~i\_subRefinement~intersect~conjg
\end{gendef}


\subsubsection{disjunctionGroup}
\begin{framed}
\noindent
\bnf{disjunctionGroup = subRefinement 1*(disjunction subRefinement)}
\end{framed}

\begin{zed}
disjunctionGroup == \\
\t2 subRefinement \cross \seq_1(subRefinement)
\end{zed}

Apply the union operator to the interpretation of each  subRefinement

\begin{gendef}
    i\_disjunctionGroup : \\
\t1 Substrate \fun disjunctionGroup \fun Sctids\_or\_Error
\where
   \forall ss : Substrate;  disjg : disjunctionGroup @ \\
i\_disjunctionGroup~ss~disjg = \\
\t1 applyToSequence~ss~i\_subRefinement~union~disjg
\end{gendef}

\subsubsection{subRefinement}
The interpretation of a \spec{subRefinement} is the interpretation of the corresponding \spec{attributeSet}, \spec{attributeGroup} or \spec{refinement}.

\begin{framed}
\noindent
\bnf{subRefinement = attributeSet / attributeGroup / "(" ws refinement ws ")?}
\end{framed}

\begin{zed}
subRefinement ::= \\
\t1 subrefine\_attset \ldata attributeSet \rdata | \\
\t1 subrefine\_attgroup \ldata attributeGroup \rdata | \\
\t1 subrefine\_refinement \ldata refinement \rdata
\end{zed}


\begin{gendef}
   i\_subRefinement : \\
\t2 Substrate \fun subRefinement \fun Sctids\_or\_Error
\where
   \forall ss : Substrate; subrefine : subRefinement @ \\
   i\_subRefinement~ss~subrefine = \\
   \IF subrefine \in \ran subrefine\_attset \\
\t1 \THEN i\_attributeSet~ss~(subrefine\_attset \inv subrefine) \\
   \ELSE \IF subrefine \in \ran subrefine\_attgroup \\
\t1 \THEN i\_attributeGroup~ss~(subrefine\_attgroup \inv subrefine) \\
  \ELSE i\_refinement~ss~(subrefine\_refinement \inv subrefine)
\end{gendef}

\subsection{attributeSet}

\begin{framed}
\noindent
\bnf{attributeSet = subAttributeSet / conjunctionAttributeSet / disjunctionAttributeSet}
\end{framed}

\begin{zed}
attributeSet ::= \\
\t1 attset\_subattset \ldata subAttributeSet \rdata | \\
\t1 attset\_conjattset \ldata conjunctionAttributeSet \rdata | \\
\t1 attset\_disjattset \ldata disjunctionAttributeSet \rdata
\end{zed}

\begin{gendef}
   i\_attributeSet : \\
\t2 Substrate \fun attributeSet \fun Sctids\_or\_Error
\where
   \forall ss : Substrate; attset : attributeSet @ \\
   i\_attributeSet~ss~attset = \\
   \IF attset \in \ran attset\_subattset \\
\t1 \THEN i\_subAttributeSet~ss~(attset\_subattset \inv attset) \\
   \ELSE \IF attset \in \ran attset\_conjattset \\
\t1 \THEN i\_conjunctionAttributeSet~ss~(attset\_conjattset \inv attset) \\
  \ELSE i\_disjunctionAttributeSet~ss~(attset\_disjattset \inv attset)
\end{gendef}

\subsubsection{conjunctionAttributeSet}
\begin{framed}
\noindent
\bnf{conjunctionAttributeSet = subAttributeSet 1*(conjunction subAttributeSet)}
\end{framed}

\begin{zed}
conjunctionAttributeSet == \\
\t2 subAttributeSet \cross \seq_1(subAttributeSet)
\end{zed}


Apply the intersect operator to the interpretation of each  subAttributeSet

\begin{gendef}
    i\_conjunctionAttributeSet : \\
\t1 Substrate \fun conjunctionAttributeSet \fun Sctids\_or\_Error
\where
   \forall ss : Substrate;  conjaset : conjunctionAttributeSet @ \\
i\_conjunctionAttributeSet~ss~conjaset = \\
\t1 applyToSequence~ss~i\_subAttributeSet~intersect~conjaset
\end{gendef}


\subsubsection{disjunctionAttributeSet}
\begin{framed}
\noindent
\bnf{disjunctionAttributeSet = subAttributeSet 1*(disjunction subAttributeSet)}
\end{framed}

\begin{zed}
disjunctionAttributeSet == \\
\t2 subAttributeSet \cross \seq_1(subAttributeSet)
\end{zed}


Apply the union operator to the interpretation of each  subAttributeSet

\begin{gendef}
    i\_disjunctionAttributeSet : \\
\t1 Substrate \fun disjunctionAttributeSet \fun Sctids\_or\_Error
\where
   \forall ss : Substrate;  disjaset : disjunctionAttributeSet @ \\
i\_disjunctionAttributeSet~ss~disjaset = \\
\t1 applyToSequence~ss~i\_subAttributeSet~union~disjaset
\end{gendef}

\subsubsection{subAttributeSet}
\begin{framed}
\noindent
\bnf{subAttributeSet = attribute / "(" ws attributeSet ws ")"}
\end{framed}

\begin{zed}
subAttributeSet ::= \\
\t1 subaset\_attribute \ldata attribute \rdata | \\
\t1 subaset\_attset \ldata attributeSet \rdata
\end{zed}

\begin{gendef}
   i\_subAttributeSet : \\
\t2 Substrate \fun subAttributeSet \fun Sctids\_or\_Error
\where
   \forall ss : Substrate; subaset : subAttributeSet @ \\
   i\_subAttributeSet~ss~subaset = \\
   \IF subaset \in \ran subaset\_attribute \\
\t1 \THEN i\_attribute~ss~(subaset\_attribute \inv subaset) \\
  \ELSE i\_attributeSet~ss~(subaset\_attset \inv subaset)
\end{gendef}

\subsection{attributeGroup}
\begin{framed}
\noindent
\bnf{attributeGroup = [cardinality ws] "\{" ws attributeSet ws "\}"}
\end{framed}

\begin{zed}
attributeGroup == \optional[cardinality] \cross attributeSet
\end{zed}

\begin{gendef}
   i\_attributeGroup : Substrate \fun attributeGroup \fun Sctids\_or\_Error
\end{gendef}



\subsection{attribute}
\begin{framed}
\noindent
\bnf{attribute = [cardinality ws] [reverseFlag ws] ws attributeName ws 
	(concreteComparisonOperator ws concreteValue / 
	expressionComparisonOperator ws expressionConstraintValue )} \\
\bnf{cardinality = "[" nonNegativeIntegerValue to (nonNegativeIntegerValue / many) "]" }
\end{framed}


\begin{zed}
   attribute ::= \\
\t1 attrib\_conc \ldata concreteAttribute \rdata | \\
\t1 attrib\_expr \ldata expressionAttribute \rdata
\end{zed}

\begin{gendef}
   i\_attribute : \\
\t1 Substrate \fun attribute \fun Sctids\_or\_Error
\where
   \forall ss : Substrate; att : attribute @ \\
   i\_attribute~ss~att = \\
   \IF att \in \ran attrib\_conc \\
\t1 \THEN i\_concreteAttribute~ss~(attrib\_conc \inv att) \\
   \ELSE i\_expressionAttribute~ss~(attrib\_expr \inv att)
\end{gendef}

For the sake of simplicity, we separate out the components of the concrete and expression constraints.

\begin{zed}
unlimitedNat ::= num \ldata \nat \rdata | many \\
cardinality == \nat \cross unlimitedNat \\
[reverseFlag] 
\end{zed}

\subsubsection{expressionAttribute}
\begin{framed}
\noindent
\bnf{expressionComparisonOperator = "=" / "!=" / "\textless\textgreater"}
\end{framed}
\begin{zed}
expressionComparisonOperator ::= eco\_eq | eco\_neq
\end{zed}


\begin{schema}{expressionAttribute}
	card : \optional[cardinality] \\
	reverse : \optional[reverseFlag] \\
	name : attributeName \\
	operator : expressionComparisonOperator \\
	value : SCTID
\end{schema}


\subsubsection{concreteAttribute}
\begin{framed}
\noindent
\bnf{concreteComparisonOperator = "=" / "!=" /  "\textless\textgreater" / "\textless=" / "\textless" / "\textgreater=" / "\textgreater"} \\
\bnf{concreteValue =  QM stringValue QM / "\#" numericValue} \\
\bnf{stringValue = 1*(anyNonEscapedChar / escapedChar)} \\
\bnf{numericValue = decimalValue / integerValue}
\end{framed}
\begin{zed}
concreteComparisonOperator ::= \\
\t3 cco\_eq | cco\_neq | cco\_leq | ccl\_lt | cco\_geq | cco\_gt \\
concreteValue ::= stringValue | integerValue | decimalValue
\end{zed}


\begin{schema}{concreteAttribute}
	card : \optional[cardinality] \\
	name : attributeName \\
	operator : concreteComparisonOperator \\
	value : concreteValue
\end{schema}


The interpretation of a \spec{concreteAttribute} selects the set of quads in the substrate that have an attribute in the set of attributes 
determined by the interpretation of \spec{attributeName} having $CONCRETEVALUE$ targets that meet the supplied comparison rules.

\begin{gendef}
   i\_concreteAttribute : \\
\t1 Substrate \fun concreteAttribute \fun Quads\_or\_Error
\where
   \forall ss : Substrate; ca : concreteAttribute @ \\
   i\_concreteAttribute~ss~ca = \\
   (\LET attids == i\_attributeName~ss~ca.name @ \\
\t1 i\_concreteAttributeConstraint~ss~attids~ca.operator~ca.value)
\end{gendef}




   
 

\subsection{Group Cardinality}
The interpretation of cardinality within a group impose additional constraints:
\begin{itemize}[noitemsep,nolistsep]
\item{$[0\upto~n]$} -- the set of all substrate concept codes that have at least one group (entry) in the substrate relationships and,
at most n matching entries in the same group
\item{$[0\upto0]$} -- the set of all substrate concept codes that have at least one group (entry) in the substrate relationships and \emph{no} matching entries 
\item{$[1..*]$} -- (default) at least one matching entry in the substrate relationships
\item{$[m_1\upto~n_1] op [m_2\upto~n_2] ... $} -- set of substrate concept codes where there exists at least one group where all conditions are simultaneously true
\end{itemize}

The interpretation of a grouped cardinality is a function from a set of SCTID's to the groups in which they were qualified.

The algorithm below partitions the input set of Quads by group and validates the cardinality on a per-group basis.  Groups that
pass are returned

\textbf{TODO:} This assumes that q.t is always type object. It doesn't say what to do if it is concrete
\textbf{TODO:} the $quads\_to\_idgroups$ function seems to express what is described below more simply
\begin{gendef}
   i\_groupCardinality : \\
\t2 Quads\_or\_Error \fun \optional[cardinality] \fun IDGroups
\where
   \forall quads : Quads\_or\_Error; oc : \optional[cardinality]; uniqueGroups : \power GROUP; \\
\t2 quadsByGroup : GROUP \pfun \power Quad |  \\
\t1    uniqueGroups = \{q : quads\_for~quads @ q.g\}  \land \\
\t1    quadsByGroup = \{g: uniqueGroups; q : \power Quad | \\
\t2 q = \{e: quads\_for~quads | e.g = g\}  @ g \mapsto (evalCardinality~oc~q) \} @ \\
i\_groupCardinality~quads~oc = \\
\t1 id\_groups~ \{sctid : SCTID; groups : \power GROUP | sctid \in \{q : \bigcup (\ran quadsByGroup) @ \\
\t2  \IF quad\_direction~quads = source\_direction \THEN q.s \ELSE object \inv q.t \} \land \\
\t1 groups = \{g: \dom quadsByGroup | (\exists q: quadsByGroup~g @ \\
\t2 sctid = \IF quad\_direction~quads = source\_direction \THEN q.s \ELSE object \inv q.t) \} @ \\
\t2 sctid \mapsto groups \}
\end{gendef}

\subsection{Cardinality}
\textbf{Interpretation:}
$cardinality$ is tested against a set of quads with the following rules:
\begin{enumerate}[noitemsep,nolistsep]
\item Errors are propagated
\item No cardinality or passing cardinality returns  the sources / targets of the set of quads
\item Otherwise return an empty set
\end{enumerate}
\begin{gendef}
   i\_cardinality :  \\
\t1 \optional[cardinality] \fun Quads\_or\_Error \fun  Sctids\_or\_Error
\where
   \forall card: \optional[cardinality]; quads : Quads\_or\_Error  @ \\
i\_cardinality~card~quads = \\
\IF quads \in \ran qerror \\
\t1 \THEN idgroups\_to\_sctids~(quads\_to\_idgroups~quads) \\
\ELSE  \\
\t1 idgroups\_to\_sctids~(quads\_to\_idgroups~(quad\_value~(evalCardinality~card~(quads\_for~quads), quad\_direction~quads))) 
\end{gendef}

\paragraph{evalCardinality}
Evaluate the cardinality of an arbitrary set of type $T$.  
\begin{itemize}[noitemsep,nolistsep]
\item If the cardinality isn't supplied ($\#opt\_cardinality = 0$), return the set.
\item If the number of elements is greater or equal to the minimum cardinality ($first~(head~opt\_cardinality)$) then:
\begin{itemize}[noitemsep,nolistsep]
\item If the max cardinality is an integer ($num \inv second~(head~opt\_cardinality)$) and it is greater than or equal to the number of elements or:
\item the max cardinality is not specified ($second~(head~opt\_cardinality) = many$)
\end{itemize}
return the set
\item Otherwise return $\emptyset$
\end{itemize}

\begin{gendef}[T]
   evalCardinality : \optional[cardinality] \fun \power T \fun \power T
\where
   \forall opt\_cardinality : \optional[cardinality]; t : \power T @ \\
evalCardinality~opt\_cardinality~t = \\
\t1 \IF \#opt\_cardinality = 0 \lor \\
\t2 (\#t \geq first~(head~opt\_cardinality)) \land \\
\t2 (second~(head~opt\_cardinality) = many \lor \\
\t2 num \inv (second~(head~opt\_cardinality)) \geq \#t) \\
\t1 \THEN t \\
\t1 \ELSE  \emptyset
\end{gendef}

% =========================================== Section 5 ===============================================

\section{Substrate Interpretations}
\label{sect:substrate}
This section defines the interpretations that are realized against the substrate. 

\subsection{attributeName}
\spec{attributeName} is the interpretation of a \spec{conceptReference} with the additional caveat that the SCTID(s) have to be substrate $attributeIds$
\begin{framed}
\noindent
\bnf{attributeName = conceptReference}
\end{framed}

\begin{zed}
attributeName == conceptReference
\end{zed}

\begin{gendef}
   i\_attributeName : \\
\t1 Substrate \fun attributeName \fun Sctids\_or\_Error
\where
   \forall ss : Substrate; attName : attributeName @ \\
   i\_attributeName~ss~attName = \\
   (\LET attn == i\_conceptReference~ss~attName @ \\
\t1 \IF attn \in \ran error \\
\t2 \THEN attn \\
\t1 \ELSE \IF (result\_sctids~attn) \subseteq ss.attributeIds \\
\t2 \THEN attn \\
\t1 \ELSE error~unknownAttributeId)
\end{gendef}



\subsection{attributeExpressionConstraint}
\spec{attributeExpressionConstraint} takes a substrate, an optional reverse flag, a set of attribute SCTIDs, an expression operator (equal or not equal) and a set of subject/target SCTIDS (depending on 
whether reverse flag is present) and returns a collection of quads that match / don't match the entry.
\begin{gendef}
   i\_attributeExpressionConstraint : \\ 
\t1 Substrate \fun \optional[reverseFlag] \fun Sctids\_or\_Error \fun \\
\t2 expressionComparisonOperator \fun Sctids\_or\_Error \fun Quads\_or\_Error
\where
   \forall ss : Substrate;  rf : \optional[reverseFlag]; atts : Sctids\_or\_Error; \\
\t1 op : expressionComparisonOperator; subj\_or\_targets : Sctids\_or\_Error @ \\
   i\_attributeExpressionConstraint~ss~rf~atts~op~subj\_or\_targets = \\
 \IF atts \in \ran error \lor subj\_or\_targets \in \ran error \\
\t1 \THEN qfirstError \{atts, subj\_or\_targets\} \\
 \ELSE \IF \# args.rf = 0 \land op = eco\_eq \THEN \\
\t1 quad\_value (\{ t : result\_sctids~subj\_or\_targets; \\
\t3 a : result\_sctids~atts; rels : ss.relationships | \\
\t3 object \inv rels.t = t \land rels.a = a @ rels \} , source\_direction) \\
\ELSE \IF \# args.rf = 1 \land op = eco\_eq \THEN \\
\t1 quad\_value (\{ s : result\_sctids~subj\_or\_targets; a : result\_sctids~atts; rels : ss.relationships | rels.s = s \land rels.t \in \ran object \land rels.a = a @ rels \} , targets\_direction) \\
 \ELSE \IF \# args.rf = 0 \land op = eco\_neq \THEN \\
\t1 quad\_value (\{ t : result\_sctids~subj\_or\_targets; a : result\_sctids~atts; rels : ss.relationships | object \inv rels.t \neq t \land rels.a = a @ rels \} , source\_direction) \\
 \ELSE \IF \# args.rf = 1 \land op = eco\_neq \THEN \\
\t1 quad\_value (\{ s : result\_sctids~subj\_or\_targets; a : result\_sctids~atts; rels : ss.relationships | rels.s \neq s \land rels.t \in \ran object \land rels.a = a @ rels \} , targets\_direction) 
\end{gendef}



\subsection{concreteAttributeConstraint}


\begin{gendef}
  i\_concreteAttributeConstraint : \\
\t1 Substrate \fun Sctids\_or\_Error \fun concreteComparisonOperator \fun\\
\t2 concreteValue \fun Quads\_or\_Error
\where
   \forall ss : Substrate; atts : Sctids\_or\_error; op : concreteComparisonOperator; \\
\t2 val : concreteValue @ \\
i\_concreteAttributeConstraint = \\
\IF atts \in \ran error \\
\t1 \THEN qerror ~ (error \inv atts) \\
   \ELSE quad\_value \{ss.relationships | ss.a \in (result\_sctids~atts) \land ss.t \in \ran concrete \land val \in concreteMatch~(concrete \inv ss.t)~op \}
\end{gendef}

\begin{gendef}
   concreteMatch : \\
\t1 CONCRETEVALUE \fun concreteComparisonOperator \fun concreteValue
\end{gendef}

\noindent
\textbf{Interpretation:}  Apply the substrate descendants ($descs$) or ancestors ($ancs$) function to a set of SCTID's in the supplied
$Sctids\_or\_Error$.  Error conditions are propagated.


\begin{gendef}
   i\_constraintOperator : \\
\t1 Substrate \pfun \optional[constraintOperator] \pfun Sctids\_or\_Error \pfun Sctids\_or\_Error
\also
   completeFun : (SCTID \pfun \power SCTID) \fun SCTID \fun \power SCTID \\
\where
	\forall ss : Substrate; oco : \optional[constraintOperator]; subresult : Sctids\_or\_Error @ \\
i\_constraintOperator~ss~oco~subresult = \\
\t1 \IF error \inv subresult \in ERROR \lor \# oco = 0 \\
\t2 \THEN subresult \\
\t1 \ELSE \IF head~oco = descendantOrSelfOf~ \\
\t2 \THEN ok (\bigcup \{id : result\_sctids~subresult @ \\
\t4 completeFun~ss.descendants~id \} \cup result\_sctids~subresult) \\
\t1 \ELSE \IF head~oco = descendantOf~ \\
\t2 \THEN ok  (\bigcup \{id : result\_sctids~subresult @ \\
\t4 completeFun~ss.descendants~id ~\}) \\
\t1 \ELSE \IF head~oco = ancestorOrSelfOf~ \\
\t2 \THEN  ok (\bigcup \{id : result\_sctids~subresult @ \\
\t4 completeFun~ss.ancestors~id \} \cup result\_sctids~subresult) \\
\t1 \ELSE  ok (\bigcup \{id : result\_sctids~subresult \\
\t4 @ completeFun~ ss.ancestors~id ~\}) \\
\also
   \forall f : (SCTID \pfun \power SCTID); id : SCTID @ completeFun~f~id = \\
\t1\IF id \in \dom f \THEN f~id \ELSE \emptyset 
\end{gendef}


\subsection{FocusConcept}
\begin{verbatim}
focusConcept = [memberOf] conceptReference
\end{verbatim}
\subsubsection{focusConcept}
\spec{focusConcept} is either a simple concept reference or the interpretation of the \spec{memberOf} function applied to a concept reference.
\begin{zed}
focusConcept ::= \\
\t1 focusConcept\_m \ldata conceptReference \rdata | \\
\t1 focusConcept\_c \ldata conceptReference \rdata
\end{zed}


\textbf{Interpretation:}  If  \spec{memberOf} is present the interpretation of  \spec{focusConcept} is union the interpretation of \spec{memberOf} applied to
each element in the interpretation of \spec{conceptReference}.  If \spec{memberOf} isn't part of the spec, the interpretation is the interpretation of \spec{conceptReference} itself

\begin{gendef}
   i\_focusConcept : Substrate \fun focusConcept \fun Sctids\_or\_Error
\where
   \forall ss : Substrate; fc : focusConcept @ \\
i\_focusConcept~ss~fc = \\
\t1 \IF focusConcept\_c \inv fc \in conceptReference \\
\t2 \THEN i\_conceptReference~ss~(focusConcept\_c~\inv fc) \\
\t1 \ELSE  i\_memberOf~ss~(i\_conceptReference~ss~(focusConcept\_m~\inv fc)) 
\end{gendef}

\subsubsection{memberOf}
\spec{memberOf} returns the union of the application of the substrate $refset$ function to each of the supplied reference set identifiers.  An error is
returned if (a) $refsetids$ already has an error or (b) one or more of the refset identifiers aren't substrate $refsetIds$

\begin{gendef}
   i\_memberOf : Substrate \fun Sctids\_or\_Error \fun Sctids\_or\_Error \\
   i\_refset : Substrate \fun SCTID \fun Sctids\_or\_Error
\where
   \forall ss : Substrate; refsetids : Sctids\_or\_Error @ \\
i\_memberOf~ss~refsetids= \\
\t1 \IF refsetids \in \ran error \\
\t2 \THEN refsetids \\
\t1 \ELSE bigunion \{sctid: result\_sctids~refsetids @ i\_refset~ss~sctid \} 
\also
  \forall ss : Substrate; sctid : SCTID @ \\
i\_refset~ss~sctid = \\
\IF sctid \notin ss.refsetIds \\
\t1 \THEN error~unknownRefsetId \\
\ELSE \IF sctid \in \dom ss.refsetIds \\
\t1 \THEN ok~(ss.refsets~sctid) \\
 \ELSE ok~\emptyset
\end{gendef}



\subsection{ConceptReferences}
\subsubsection{conceptId}
\begin{verbatim}
conceptId = sctId
\end{verbatim}
\textbf{Interpretation}: \spec{conceptId} is interpreted as $SCTID$ that it represents.  For our purposes, all \spec{conceptId}s are considered valid, so this is a bijection.
\begin{zed}
[conceptId]
\end{zed}

\begin{gendef}
   i\_conceptId : conceptId \bij SCTID
\end{gendef}

\subsubsection{conceptReference}
\begin{verbatim}
conceptReference = conceptId [ "|" Term "|"]
conceptId = sctId
\end{verbatim}
\textbf{Interpretation:}  \spec{conceptReference} is interpreted as the \emph{set of} $SCTID$s that are equivalent to the supplied SCTID if it is known concepts, $c$,
in the substrate.  If it isn't in the list of known concepts otherwise as the $unknownConceptReference$ error.  The \spec{Term} part of \spec{conceptReference} is ignored.

\begin{zed}
conceptReference == conceptId
\end{zed}

\begin{gendef}
   i\_conceptReference : Substrate \fun conceptReference \fun Sctids\_or\_Error \\
\where
   \forall ss: Substrate; c : conceptReference @ i\_conceptReference~ss~c = \\
\t1 (\LET sctid == i\_conceptId~c @ \\
\t1 \IF sctid \in ss.concepts \THEN ok ~ (ss.equivalent\_concepts~ sctid) \\
\t1 \ELSE error~ unknownConceptReference)
\end{gendef}

\section{Glue and Helper Functions}
This section carries various type transformations and error checking functions

\subsection{Types}

\begin{itemize}[noitemsep,nolistsep]
\item \textbf{direction} -- an indicator whether a collection of quads was determined as source to target ($source\_direction$) or target to source ($targets\_direction$)
\item \textbf{Quads\_or\_Error} --  a collection of $Quad$s or an error condition. If it is a collection $Quad$s, it also carries
a direction indicator that determines whether it represents a set of sources or targets. 
\item \textbf{IDGroups} -- a map from $SCTID$s to the $GROUP$ they were in when they passed if successful, otherwise an error indication.
\end{itemize}

\begin{zed}
direction ::= source\_direction | targets\_direction \\
Quads\_or\_Error ::= quad\_value \ldata \power Quad \cross direction \rdata | qerror \ldata ERROR \rdata \\
\also
IDGroups ::= id\_groups \ldata SCTID \pfun \power GROUP \rdata | gerror \ldata ERROR \rdata
\end{zed}

\subsection{Result transformations}
\begin{itemize}[noitemsep,nolistsep]
\item \textbf{result\_sctids} -- the set of $SCTID$s in $Sctids\_or\_Error$ or the empty set if there is an error
\item \textbf{quads\_for} -- the set of quads in a $Quads\_or\_Error$ or an empty set if there is an error
\item \textbf{quad\_direction} -- the direction of a $Quads\_or\_Error$ result.  Undefined if error
\item \textbf{to\_idGroups} -- the $SCTID$ to $GROUP$ part of in an id group or an empty map if there is error
\item \textbf{quads\_to\_idgroups} -- convert a set of quads int a set of id groups using the following rules:
\begin{itemize}[noitemsep,nolistsep]
\item If the set of quads has an error, propagate it
\item If the quad direction is $source\_direction$ (target to source) a list of unique relationship subjects and, for each subjects, the set of different groups it appears as a subject in
\item Otherwise return a list of relationship target sctids and, for each target, the set of different groups it appears as a target in.
\end{itemize}
\item \textbf{idgroups\_to\_sctids} -- remove the groups and return an $Sctids\_or\_Error$ for the ids
\end{itemize}
\begin{gendef}
   result\_sctids: Sctids\_or\_Error \fun \power SCTID \\
   quads\_for: Quads\_or\_Error \fun \power Quad  \\
   quad\_direction: Quads\_or\_Error \pfun direction \\
   to\_idGroups: IDGroups \fun SCTID \fun \power GROUP \\
   quads\_to\_idgroups: Quads\_or\_Error \fun IDGroups \\
   idgroups\_to\_sctids: IDGroups \fun Sctids\_or\_Error \\
\where
   \forall r: Sctids\_or\_Error @ result\_sctids~r = \\
\t1 \IF error \inv r \in ERROR \THEN \emptyset \\
\t1 \ELSE ok \inv r
\also
   \forall q : Quads\_or\_Error @ quads\_for~q = \\
\t1 \IF qerror \inv q \in ERROR \THEN \emptyset \\
\t1 \ELSE first~(quad\_value \inv q)
\also
   \forall q : Quads\_or\_Error @ quad\_direction~q = \\
\t1 second~(quad\_value \inv q)
\also
   \forall g : IDGroups @ to\_idGroups~g = \\
\t1 \IF gerror \inv g \in ERROR \THEN \emptyset \\
\t1 \ELSE id\_groups \inv g
\also
   \forall q : Quads\_or\_Error @ quads\_to\_idgroups~q = \\
\t1 \IF qerror  \inv q \in ERROR \THEN gerror (qerror \inv q) \\
\t1 \ELSE \IF quad\_direction~q = source\_direction \\
\t2 \THEN id\_groups~\{s : SCTID | (\exists qr : quads\_for~q @ s = qr.s) @ \\
\t2 s \mapsto \{qr : quads\_for~q @ qr.g\} \} \\
\t1 \ELSE \\
\t2 id\_groups~\{t : SCTID | (\exists qr : quads\_for~q @ t = object \inv qr.t ) @ \\
\t2 t \mapsto \{qr : quads\_for~q @ qr.g\} \} 
\also
   \forall g : IDGroups @ idgroups\_to\_sctids~g = \\
\t1 \IF g \in \ran gerror \THEN ok~\emptyset \\
\t1 \ELSE ok~(\dom (id\_groups \inv g))
\end{gendef}



\paragraph{}
Definition of the various functions that are performed on the result type. \\
\begin{itemize}[noitemsep,nolistsep]
\item \textbf{firstError} -- aggregate one or more $Sctids\_or\_Error$ types, at least one of which carries and error and merge them into a single $Sctid\_or\_Error$ instance propagating at least one of the errors (Not fully defined)
\item \textbf{qfirstError} -- convert two $Sctids\_or\_Error$ types, into a $Quads\_or\_Error$ propagating at least one of the errors. (not fully defined)
\end{itemize}

\begin{itemize}[noitemsep]
\item \textbf{union} -- return the union of two $Sctids\_or\_Error$ types, propagating errors if they exist, else returning the union of the SCTID sets.
\item \textbf{intersect} --return the intersection of two $Sctids\_or\_Error$ types, propagating errors if they exist, else returning the intersection of the SCTID sets.
\item \textbf{minus} -- return the difference of one $Sctids\_or\_Error$ type and a second, propagating errors if they exist, else returning the set of SCTID's in the first set that aren't in the second. 
\item \textbf{bigunion} -- return the union of a set of $Sctids\_or\_Error$ types, propagating errors if they exist, else returning the union of  all of the SCTID sets.
\item \textbf{bigintersect} -- return the intersection a set of $Sctids\_or\_Error$ types, propagating errors if they exist, else returning the intersection of all of  the SCTID sets.
\end{itemize}

\begin{gendef}
   firstError : \power Sctids\_or\_Error \pfun Sctids\_or\_Error \\
   qfirstError : \power Sctids\_or\_Error \pfun Quads\_or\_Error 
\also
   union, intersect, minus : Sctids\_or\_Error \fun Sctids\_or\_Error \fun \\
\t2 Sctids\_or\_Error \\
   bigunion, bigintersect : \power Sctids\_or\_Error \fun Sctids\_or\_Error \\
\where
   \forall x,y : Sctids\_or\_Error @ union~x~y = \\
\t1 \IF x \in \ran error \lor  y \in \ran error \THEN firstError~\{x, y\} \\
\t1 \ELSE ok~((ok \inv x) \cup (ok \inv y))
\also
   \forall x,y : Sctids\_or\_Error @ intersect~x~y = \\
\t1 \IF x \in \ran error \lor y \in \ran error \THEN firstError~\{x, y\} \\
\t1 \ELSE ok~((ok \inv x) \cap (ok \inv y))
\also
   \forall x,y : Sctids\_or\_Error @ minus~x~y = \\
\t1 \IF x \in \ran error \lor y \in \ran error \THEN firstError~\{x, y\} \\
\t1 \ELSE ok~((ok \inv x) \setminus (ok \inv y))
\also
  \forall rs : \power Sctids\_or\_Error @ bigunion~rs = \\
\t1 \IF \exists r : rs @ r \in \ran error \THEN firstError~ rs \\
\t1 \ELSE ok~(\bigcup \{r : rs @ result\_sctids~r\})
\also
  \forall rs : \power Sctids\_or\_Error @ bigintersect~rs = \\
\t1 \IF \exists r : rs @ r \in \ran error \THEN firstError~ rs \\
\t1 \ELSE ok~(\bigcap \{r : rs @ result\_sctids~r\})
\end{gendef}

   

\section{Appendix 1}
Representing optional elements of type $T$.  Representing it as a sequence allows us to
determine absence by $\#T = 0$ and the value by $head~T$. 

\begin{zed} 
  \optional[T] == \{ s : \seq T \mid \# s \leq 1 \} 
\end{zed}

\section{Appendix 2}
A generic function that takes:
\begin{itemize}[noitemsep]
\item A substrate
\item A function that takes a substrate, a sequence of type $T$ and returns $Sctids\_or\_Error$  (example: $i\_subExpressionConstraint$)
\item An operator that takes two $Sctids\_or\_Error$ and returns a combination (example: $union$)
\item A structure of the form "$T \cross \seq_1 T$
\end{itemize}

And returns $Sctids\_or\_Error$

In the formalization below, $first ~seq\_e$ refers to the left hand side of the $T \cross \seq_1 T$ and
$second ~seq\_e$ to the right hand side.  $head (second~seq\_e)$ refers to the first element in the sequence and 
$tail (second~seq\_e)$ refers to the remaining elements in the sequence, which may be empty ($\langle \rangle$).

\begin{gendef}[T]
    applyToSequence : Substrate \fun (Substrate \fun T \fun Sctids\_or\_Error) \fun \\
\t1 (Sctids\_or\_error \fun Sctids\_or\_error \fun Sctids\_or\_error) \fun \\
\t1 (T \cross \seq_1 T) \fun Sctids\_or\_Error
\where
   \forall ss : Substrate;  f: (Substrate \fun T \fun Sctids\_or\_Error); \\
\t1 op: (Sctids\_or\_error \fun Sctids\_or\_error \fun Sctids\_or\_error); \\
\t1 seq\_e:  (T \cross \seq_1 T) @ \\
applyToSequence~ss~f~op~seq\_e = \\
   \IF tail(second~seq\_e) = \langle \rangle \THEN \\
\t1 op~(f~ss~(first~seq\_e)) (f~ss~(head~(second~seq\_e))) \\
   \ELSE \\
\t1 op~(f~ss~(first~seq\_e)) (f~ss~((head(second~seq\_e)) (tail(second~seq\_e))))
\end{gendef}
   

\end{document}


   

