\documentclass{article}
\usepackage{enumitem}
\usepackage{zed}
\usepackage{verbatim}
\usepackage{framed}

\def\spec#1{{\tt #1}}
\def\req#1{{\sf {{\bf #1}} }}


\raggedbottom
\include{uml_style}

\begin{document}
\tableofcontents

\section{Axiomatic Data Types}
\subsection{Atomic Data Types}
This section identifies the atomic data types that are assumed for the rest of this specification, specifically:
\begin{itemize}[noitemsep]
\item \textbf{SCTID} -- a SNOMED CT identifier
\item \textbf{TERM} --  a  fully specified name, preferred term or synonym for a SNOMED CT Concept
\item \textbf{REAL} --  a real number
\item \textbf{STRING} -- a string literal
\item \textbf{GROUP} -- a role group identifier
\item \textbf{$\nat$} -- a non-negative integer
\item \textbf{$\num$} -- an integer
\end{itemize}


We also introduce several synonyms for $SCTID$:
\begin{itemize}[noitemsep]
\item \textbf{SUBJECT} -- a $SCTID$ that appears in the \emph{sourceId} position of a relationship.
\item \textbf{ATTRIBUTE} -- a $SCTID$ that appears in the \emph{typeId} position of a relationship.
\item \textbf{OBJECT} -- a $SCTID$ that appears in the \emph{destinationId} position of a relationship.
\item \textbf{REFSETID} -- a $SCTID$ that identifies a reference set
\end{itemize}

\begin{zed}
[SCTID, TERM, REAL, STRING, GROUP] \\
\also
SUBJECT == SCTID \\
ATTRIBUTE == SCTID \\
OBJECT == SCTID \\
REFSETID == SCTID 
\end{zed}

\subsection{Composite Data Types}
While we can't fully specify the behavior of the concrete data types portion of the specification at this point, it is still useful 
to spell out the anticipated behavior on an abstract level.
\begin{itemize}[noitemsep,nolistsep]
\item \textbf{CONCRETEVALUE} -- a string, integer or real literal
\item \textbf{TARGET} -- the target of a relationship that is either an OBJECT or a CONCRETEVALUE
\end{itemize}
\begin{zed}
CONCRETEVALUE ::= string \ldata STRING \rdata | integer \ldata \num \rdata | real \ldata REAL \rdata \\
TARGET ::= object \ldata OBJECT \rdata | concrete \ldata CONCRETEVALUE \rdata
\end{zed}

\section{The Substrate}
A substrate represents the context of an interpretation.  A substrate consists of:


\begin{itemize}[noitemsep,nolistsep]
\item{\textbf{c}} The set of $SCTID$s (concepts) that are considered valid in the context of the substrate.  \req{References to any $SCTID$ that is
not a member of this set MUST be treated as an error.}
\item{\textbf{a}} The set of $SCTID$s that are considered to be valid attributes in the context of the substrate.  \req{Reference to any $ATTRIBUTE$ that is
not a member of this set MUST be treated as an error.}
\item{\textbf{r}} A set of relationship quads (subject, attribute, target, group)
\item{\textbf{descs}} The subsumption (ISA) closure from general to specific (descendants)
\item{\textbf{ancs}}  The subsumption (ISA) closure from specific to general (ancestors)
\item{\textbf{refset}} The reference sets within the context of the substrate whose members are members are concept identifiers (i.e. are in $c$).  While not formally spelled out in this specification, it is assumed that the typical reference set function would be returning a subset of the $refsetId$/$referencedComponentId$ tuples represented in one or more RF2 Refset Distribution tables.
\end{itemize}

\paragraph{Open questions:}
While the Core will not contain cycles, and probably NRC Extensions will not, arbitrary extensions (e.g. as a result of handling Expression libraries) may involve cycles (or at least equivalent concepts).
\begin{itemize}
\item \textbf{Resolution: } A reflexive, symmetric equivalence relationship ($equiv$) was added to the substrate.  How it is determined is left unspecified, but a rule was added saying that an equivalent concept can not be a descendant of its equivalence.
\item Is it correct to interpret the transitive closure directly against the substrate relationships ($r$) set or is there an implication of a reasoner being invoked somewhere, which 
could potentially render the transitive closure as logically derived from ($r$).  \textbf{Answer: } If substrate includes postcoordinated expressions then subsumption would need to be calculated. \textbf{Followup: } How does one know whether it includes postcoordinated expressions?  How do we express this decision formally?
\item Do we want to assert that it is an error to use a non-attribute concept in a attribute position?  If not, should we explicitly include a formal definition of the attribute set? \textbf{Answer: }  Because the ECL doesn't declare this as an error condition, we shouldn't assert in the Z spec.  \textbf{Resolution: } $   a = descs~attribute\_concept $ assertion pulled from the substrate declaration.
\end{itemize}
\subsection{Substrate Components}
\paragraph{Quad}
Relationships in the substrate are represented a 4 element tuples or ``Quads'', which consist of a subject, attribute, target and role group identifier.

\begin{schema}{Quad}
   s : SUBJECT \\
   a : ATTRIBUTE \\
   t : TARGET \\
   g : GROUP
\end{schema}


We will also need to recognize some "well known" identifiers: the $is\_a$ attribute, the $zero\_group$ and  $attribute\_concept$, the parent of all attributes
\begin{axdef}
is\_a : ATTRIBUTE \\
zero\_group : GROUP \\
attribute\_concept : SCTID \\
refset\_concept : SCTID
\end{axdef}

\subsection{Substrate}
The formal definition of substrate follows, where c and r are given and the remainder are derived.  The expressions below assert that:
\begin{enumerate}
\item All subjects and attributes and targets of type $object$ in $r$  must be members of the set of concepts, $c$.  All attributes are also members of $a$.
\item The $is_a$ relation is irreflexive.
\item $childrenOf$ \emph{includes} the function from a concept in $c$ to the set of concepts that are the source of $c$ in an $is\_a$ relationship in the $zero\_group$.  Note that 
substrates that include post-coordinated expressions may include additional entries in the $childrenOf$ function that are not in the relationships table and, instead, are derived 
through the application of a DL reasoner.
\item $parentsOf$ \emph{includes} the function from a concept $c$ to the set of concepts that are the target of of $c$ in an $is\_a$ relationship in the $zero\_group$.  Note that 
substrates that include post-coordinated expressions may include additional entries in the $parentsOf$ function that are not in the relationships table and, instead, are derived 
through the application of a DL reasoner.
\item $parentsOf$ and $childrenOf$ are irreflexive.
\item The $equiv$ relationship is symmetric and reflexive.
\item The ancestors function, $ancs$ ,is the \emph{irreflexive} transitive closure of the $childrenOf$ relationship.
\item The descendants function, $descs$, is the  \emph{irreflexive} transitive closure of the inverse of the $parentsOf$ relationship. 
\item The descendants relationship must not contain any concepts that are declared as equivalent to the root.
\item The reference set function is a function from  \emph{subset of} $c$ to set of SCTID's in $c$.  A SCTID that is not in the domain of $refset$ cannot appear as the target of a $memberOf$ function
\end{enumerate}
\begin{schema}{Substrate}
   c : \power SCTID \\
   r : \power Quad  \\
   a : \power SCTID
\also
   childrenOf : SCTID \pfun \power SCTID \\
   parentsOf : SCTID \pfun \power SCTID
\also
   descs : SCTID \pfun \power SCTID \\
   ancs : SCTID \pfun \power SCTID \\
   equiv : \power (SCTID \cross SCTID) \\
   refset : REFSETID \pfun \power SCTID \\
\where
   \forall rel : r @  rel.s \in c \land rel.a \in c \land (object \inv rel.t \in SCTID \implies object \inv rel.t \in c)  \\
   \forall q : r @ q.a \in a \land q.a = is\_a \implies q.s \neq object \inv q.t \\
   \forall q : r @ q.a \in descs~attribute\_concept
\also
    \dom childrenOf \subseteq c \land \bigcup (\ran childrenOf) \subseteq c \\
    \forall s : c @ parentsOf~s = \{q: r | q.s = s \land q.a = is\_a \land q.g = zero\_group @ object \inv q.t \} \\
    \forall t : c @ childrenOf~t = \{q: r | q.a = is\_a \land q.t = object~t \land q.g = zero\_group @ q.s \} \\
    \forall c1, c2 : c @ c1 \in parentsOf~c2 \iff c2 \in childrenOf~c1
\also
   \forall x : c @ (x \mapsto x) \in equiv \\
   \forall x_1, x_2 : c @ x_1 \mapsto x_2 \in equiv \implies x_2 \mapsto x_1 \in equiv
\also
   \forall s : c @ descs~s = childrenOf~ s \cup \bigcup \{t : childrenOf~ s @ descs~t\} \\
   \forall t : c @ ancs~t = parentsOf~ t \cup \bigcup \{s : parentsOf~ t @ ancs~s\} \\
   \forall r: equiv @ first~r \in \dom descs \implies second~r \notin (descs~(first~r))
\also
    \dom refset \subseteq descs~refset\_concept \land \bigcup (\ran refset) \subseteq c
\end{schema}


\section{Result}
The result of applying a query against a substrate is either a (possibly empty) set of SCTID's or an $ERROR$.
\begin{zed}
ERROR ::= unknownOperation | unknownConceptReference | \\
\t3 unknownAttribute | unknownRefsetId 
\also
Result ::= ok \ldata \power SCTID \rdata | error \ldata ERROR \rdata 
\end{zed}
\section{Interpretation of Intermediate Constructs}
This section carries the interpretation of the intermediate constructs -- the various forms
of expressions and their combinations.
\subsection{expressionConstraint}
\begin{framed}
expressionConstraint = \\
\t2 ( refinedExpressionConstraint / unrefinedExpressionConstraint ) 
\end{framed}

\subsubsection{Interpretation}
The interpretation of \spec{expressionConstraint} the interpretation of the  \spec{refinedExpressionConstraint}
or the \spec{unrefinedExpressionConstraint}.
\begin{zed}
expressionConstraint ::= \\
\t2 ecrec \ldata refinedExpressionConstraint \rdata | \\
\t2 ecurec \ldata unrefinedExpressionConstraint \rdata \\
\end{zed}


\begin{gendef}
   i\_expressionConstraint : \\
\t2 Substrate \fun expressionConstraint \fun Result
\where
   \forall ss: Substrate; ec: expressionConstraint @ i\_expressionConstraint~ss~ec = \\
\t1 \IF ecrec \inv ec \in refinedExpressionConstraint \\
\t2 \THEN i\_refinedExpressionConstraint~ss~(ecrec \inv ec) \\
\t1 \ELSE \IF ecurec \inv ec \in unrefinedExpressionConstraint \\
\t2 \THEN i\_unrefinedExpressionConstraint~ss~(ecurec \inv ec) \\
\t1 \ELSE error~ unknownOperation
\end{gendef}

\subsubsection{unrefinedExpressionConstraint}
An \spec{unrefinedExpressionConstraint} is either a \spec{compoundExpressionConstraint} or a \spec{simpleExpressionConstraint}

\begin{verbatim}
unrefinedExpressionConstraint = 
    compoundExpressionConstraint / simpleExpressionConstraint
\end{verbatim}

\begin{zed}
unrefinedExpressionConstraint ::= \\
\t2 ucec \ldata compoundExpressionConstraint \rdata | \\
\t2 usec \ldata simpleExpressionConstraint \rdata
\end{zed}
\begin{gendef}
   i\_unrefinedExpressionConstraint : \\
\t2 Substrate \fun unrefinedExpressionConstraint \fun Result
\where
   \forall ss : Substrate; uec : unrefinedExpressionConstraint @  \\
   i\_unrefinedExpressionConstraint~ss~uec = \\
\t1 \IF ucec \inv uec \in compoundExpressionConstraint \\
\t2 \THEN i\_compoundExpressionConstraint~ss~(ucec \inv uec) \\
\t1 \ELSE \IF usec \inv uec \in simpleExpressionConstraint  \\
\t2 \THEN i\_simpleExpressionConstraint~ss~(usec \inv uec) \\
\t1 \ELSE  error~ unknownOperation
\end{gendef}

\subsubsection{refinedExpressionConstraint}
\begin{verbatim}
refinedExpressionConstraint = 
     unrefinedExpressionConstraint ":" refinement /		
     "(" refinedExpressionConstraint ")"
\end{verbatim}

The interpretation of \spec{refinedExpressionConstraint} is the intersection of the interpretation of
the \spec{unrefinedExpressionConstraint} and the \spec{refinement}, both of which return a set of SCTID's or
an error.

The interpretation of the second option adds no value.
\begin{zed}
refinedExpressionConstraint == \\
\t2 unrefinedExpressionConstraint \cross refinement
\end{zed}

\begin{gendef}
   i\_refinedExpressionConstraint : \\
\t2 Substrate \pfun refinedExpressionConstraint \pfun Result
\where
   \forall ss : Substrate; rec : refinedExpressionConstraint @ \\
   i\_refinedExpressionConstraint~ss~rec = \\
\t1 intersect~(i\_unrefinedExpressionConstraint~ss~(first~rec)) (i\_refinement~ss~(second~rec))
\end{gendef}


\subsection{simpleExpressionConstraint}
The interpretation of  \spec{simpleExpressionConstraint} is the application of an optional constraint 
operator to the interpretation of \spec{focusConcept}, which returns a set of SCTID's or an error.
The interpretation of an error is the error.


\begin{verbatim}
simpleExpressionConstraint =  
     [constraintOperator ] focusConcept
\end{verbatim}


\begin{zed}
constraintOperator ::= descendantOrSelfOf | descendantOf |  \\
\t2 ancestorOrSelfOf | ancestorOf \\
simpleExpressionConstraint == \optional[constraintOperator] \cross focusConcept 
\end{zed} 

\begin{gendef}
   i\_simpleExpressionConstraint : \\
\t2 Substrate \pfun simpleExpressionConstraint \pfun Result
\where
   \forall ss : Substrate; sec : simpleExpressionConstraint @ \\
i\_simpleExpressionConstraint~ss~sec =  \\
\t2 i\_constraintOperator~ss~(first~sec)~(i\_focusConcept~ss~(second~sec))
\end{gendef}


\subsection{compoundExpressionConstraint}
The interpretation of a $compoundExpressionConstraint$ is the interpretation of its corresponding component.
\begin{verbatim}
compoundExpressionConstraint = conjunctionExpressionConstraint |
       disjunctionExpressionConstraint | exclusionExpressionConstraint |
        "(" compoundExpressionConstraint ")"
\end{verbatim}

\begin{zed}
compoundExpressionConstraint ::= \\
\t2 cecConj \ldata conjunctionExpressionConstraint \rdata | \\
\t2 cecDisj \ldata disjunctionExpressionConstraint \rdata | \\
\t2 cecExc \ldata exclusionExpressionConstraint \rdata 
\end{zed}

\begin{gendef}
   i\_compoundExpressionConstraint : \\
\t2 Substrate \pfun compoundExpressionConstraint \pfun Result
\where
  \forall ss : Substrate; cec : compoundExpressionConstraint @ \\
 i\_compoundExpressionConstraint~ss~cec = \\
 \t1 \IF cecConj \inv cec \in conjunctionExpressionConstraint \\
\t2 \THEN i\_conjunctionExpressionConstraint~ss~(cecConj \inv cec) \\
 \t1 \ELSE \IF cecDisj \inv cec \in disjunctionExpressionConstraint \\
\t2 \THEN i\_disjunctionExpressionConstraint~ss~(cecDisj \inv cec) \\
 \t1 \ELSE \IF cecExc \inv cec \in exclusionExpressionConstraint \\
\t2 \THEN i\_exclusionExpressionConstraint~ss~(cecExc \inv cec) \\
\t1 \ELSE error~ unknownOperation
\end{gendef}

\begin{gendef}
   i\_compoundExpressionConstraint' : \\
\t2 Substrate \pfun compoundExpressionConstraint \pfun Result
\end{gendef}


\subsection{conjunctionExpressionConstraint}
$conjunctionExpressionConstraint$ is interpreted the conjunction (intersection) of the interpretation of two or more
$subExpressionConstraints$
\begin{verbatim}
conjunctionExpressionConstraint = 
        subExpressionConstraint 1*(conjunction subExpressionConstraint)
\end{verbatim}

\begin{zed}
conjunctionExpressionConstraint == subExpressionConstraint \cross \seq_1(subExpressionConstraint)
\end{zed}

\begin{gendef}
    i\_conjunctionExpressionConstraint : \\
\t2 Substrate \pfun conjunctionExpressionConstraint \pfun Result
\where
   \forall ss : Substrate;  cecr : conjunctionExpressionConstraint @ \\
i\_conjunctionExpressionConstraint~ss~cecr = \\
\t1 \IF tail(second~cecr) = \langle \rangle \THEN \\
\t2 intersect~~(i\_subExpressionConstraint~ss~(first~cecr)) (i\_subExpressionConstraint~ss~(head~(second~cecr))) \\
\t1 \ELSE \\
\t2 intersect~~(i\_subExpressionConstraint~ss~(first~cecr)) (i\_conjunctionExpressionConstraint~ss~((head(second~cecr)), (tail(second~cecr))))
\end{gendef}

\subsection{disjunctionExpressionConstraint}
$disjunctionExpressionConstraint$ is interpreted the disjunction (union) of the interpretation of two or more
$subExpressionConstraints$
\begin{verbatim}
disjunctionExpressionConstraint = 
      subExpressionConstraint 1*(disjunction subExpressionConstraint)
\end{verbatim}

\begin{zed}
disjunctionExpressionConstraint == \\
\t2 subExpressionConstraint \cross \seq_1(subExpressionConstraint)
\end{zed}

\begin{gendef}
    i\_disjunctionExpressionConstraint : \\
\t2 Substrate \pfun disjunctionExpressionConstraint \pfun Result
\where
   \forall ss : Substrate;  cecr : disjunctionExpressionConstraint @ \\
i\_disjunctionExpressionConstraint~ss~cecr = \\
\t1 \IF tail(second~cecr) = \langle \rangle \THEN \\
\t2 union~~(i\_subExpressionConstraint~ss~(first~cecr)) (i\_subExpressionConstraint~ss~(head~(second~cecr))) \\
\t1 \ELSE \\
\t2 union~~(i\_subExpressionConstraint~ss~(first~cecr)) (i\_disjunctionExpressionConstraint~ss~((head(second~cecr)), (tail(second~cecr))))
\end{gendef}

\subsection{exclusionExpressionConstraint}
$exclusionExpressionConstraint$ is interpreted the result of removing the members of the second
$subExpressionConstraint$ from the first
\begin{verbatim}
exclusionExpressionConstraint = 
      subExpressionConstraint exclusion subExpressionConstraint
\end{verbatim}

\begin{zed}
exclusionExpressionConstraint == \\ 
\t2subExpressionConstraint \cross subExpressionConstraint
\end{zed}

\begin{gendef}
    i\_exclusionExpressionConstraint : \\
\t2 Substrate \pfun exclusionExpressionConstraint \pfun Result
\where
   \forall ss : Substrate; ecr : exclusionExpressionConstraint @ \\
i\_exclusionExpressionConstraint~ss~ecr = \\
\t1~ minus~~ (i\_subExpressionConstraint~ss~(first~ecr))~ (i\_subExpressionConstraint~ss~(second~ecr))
\end{gendef}

\subsection{subExpressionConstraint}
$subExpressionConstraint$ is interpreted as the interpretation of either a $simpleExpressionConstraint$
or a $compoundExpressionConstraint$
\begin{verbatim}
subExpressionConstraint =
      simpleExpressionConstraint | "(" compoundExpressionConstraint ")
\end{verbatim}

\begin{zed}
subExpressionConstraint ::= \\
\t1 secSec \ldata simpleExpressionConstraint \rdata | \\
\t1 secCec \ldata compoundExpressionConstraint \rdata
\end{zed}

\begin{gendef}
   i\_subExpressionConstraint : \\
\t2 Substrate \pfun subExpressionConstraint \pfun Result
\where
   \forall ss : Substrate; sec : subExpressionConstraint @ \\
i\_subExpressionConstraint~ss~sec = \\
\t1 \IF (secSec \inv sec) \in simpleExpressionConstraint \\
\t2 \THEN i\_simpleExpressionConstraint~ss~(secSec \inv sec) \\
 \t1 \ELSE \IF secCec \inv sec \in compoundExpressionConstraint \\
\t2 \THEN i\_compoundExpressionConstraint'~ss~(secCec \inv sec) \\
\t1 \ELSE error~ unknownOperation
\end{gendef}


\subsection{refinement}
\spec{refinement} is the interpretation of one or more \spec{attribute} or \spec{attributeGroup}s joined
by \spec{binaryOperator}s

\begin{verbatim}
binaryOperator = conjunction / disjunction / minus
refinement = (attribute / attributeGroup / "(" refinement ")") 
         [binaryOperator 	refinement]
\end{verbatim}
\begin{zed}
refTarget ::= att \ldata attribute \rdata | attg \ldata attributeGroup \rdata \\
refinement == refTarget  \cross \seq(binaryOperator \cross refTarget)\\
\end{zed}

\begin{gendef}
   i\_refTarget : Substrate \fun refTarget \fun Result \\
   i\_refinement : Substrate \fun refinement \fun Result
\where
   \forall ss : Substrate; rt : refTarget @ i\_refTarget~ss~rt = \\
\t1 \IF att \inv rt \in attribute \\
\t2 \THEN i\_attribute~ss~(att \inv rt) \\
\t1 \ELSE \IF attg \inv rt \in attributeGroup \\
\t2 \THEN i\_attributeGroup~ss~(attg \inv rt) \\
\t1 \ELSE error~ unknownOperation
\also
   \forall ss : Substrate; ref : refinement @ \\
\t1i\_refinement~ss~ref = \\
\t1 evalRefinement~ss~(i\_refTarget~ss~(first~ref))~(second~ref)
\end{gendef}

\begin{gendef}
   evalRefinement : \\
\t2 Substrate \fun Result \fun \seq (binaryOperator \cross refTarget) \fun Result
\where
   \forall ss : Substrate; r: Result; opt : \seq(binaryOperator \cross refTarget) @ \\
\t1 evalRefinement~ss~r~opt = \\
\t2 \IF opt = \langle \rangle \\
\t3 \THEN r \\
\t2 \ELSE \IF first~(head~opt) = conjunction \\
\t3  \THEN  evalRefinement~ss~(intersect~ r (i\_refTarget'~ss~(second~(head~opt))))~(tail~opt) \\
\t2 \ELSE \IF first~(head~opt)  = disjunction \\
\t3  \THEN  evalRefinement~ss~(union~ r (i\_refTarget'~ss~(second~(head~opt))))~(tail~opt) \\
\t2 \ELSE \IF first~(head~opt)  = exclusion \\
\t3  \THEN  evalRefinement~ss~(minus~ r (i\_refTarget'~ss~(second~(head~opt))))~(tail~opt) \\
\t2 \ELSE error~ unknownOperation
\end{gendef}
\begin{gendef}
   i\_refTarget' : Substrate \fun refTarget \fun Result
\end{gendef}



\subsection{expressionConstraintValue}
\begin{verbatim}
expressionConstraintValue = simpleExpressionConstraint / 
       "(" (refinedExpressionConstraint / 			
       compoundExpressionConstraint) ")"
\end{verbatim}

\begin{zed}
expressionConstraintValue ::= ecvsec \ldata simpleExpressionConstraint \rdata | \\
\t2 ecvrec \ldata refinedExpressionConstraint' \rdata | \\
\t2 ecvcec \ldata compoundExpressionConstraint \rdata \\
[refinedExpressionConstraint']
\end{zed}
\begin{gendef}
   i\_expressionConstraintValue : Substrate \fun \\
\t2 expressionConstraintValue \fun Result
\where
   \forall ss : Substrate; ecv : expressionConstraintValue @  \\
   i\_expressionConstraintValue~ss~ecv = \\
\t1 \IF ecvsec \inv ecv \in simpleExpressionConstraint \\
\t2 \THEN i\_simpleExpressionConstraint~ss~(ecvsec \inv ecv) \\
\t1 \ELSE \IF ecvrec \inv ecv \in refinedExpressionConstraint' \\ 
\t2 \THEN i\_refinedExpressionConstraint'~ss~(ecvrec \inv ecv) \\
\t1 \ELSE \IF ecvcec \inv ecv \in compoundExpressionConstraint \\ 
\t2 \THEN i\_compoundExpressionConstraint~ss~(ecvcec \inv ecv) \\
\t1 \ELSE error~ unknownOperation
\end{gendef}

\begin{gendef}
   i\_refinedExpressionConstraint' : \\
\t2 Substrate \pfun refinedExpressionConstraint' \pfun Result
\end{gendef}




\subsection{Attributes and Attribute Groups}
The interpretation of an attribute.  \spec{attributeOperator} and \spec{attributeName}
determines the set of possible attributes in the substrate relationship table.  \spec{reverseFlag} and
\spec{expressionConstraintValue} determine the set of candidate targets (if \spec{reverseFlag}
is absent) or \spec{subjects} (if \spec{reverseFlag} is present).

\spec{cardinality} determines the minimum and maximum matches.  In all cases, only a subset of the subjects 
(targets if \spec{reverseFlag} is present) in the substrate relationship table will be returned in the interpretation.



\begin{verbatim}
attribute = [cardinality] [reverseFlag] [attributeOperator] attributeName 			
       (comparisonOperator concreteValue / "=" expressionConstraintValue )
attributeGroup = "{" attributeSet "}" 
attributeSet = attribute [binaryOperator  attributeSet] / "(" attributeSet ")" 
cardinality = "[" nonNegativeIntegerValue to (nonNegativeIntegerValue / many) "]" 
attributeOperator = descendantOrSelfOf / descendantOf 
comparisonOperator = "=" / "!" ws "=" / 
    ("n"/"N") ("o"/"O") ("t"/"T") ws "=" / "<=" / "<" / ">=" /  ">"
\end{verbatim}

\subsection{AttributeName and AttributeSubject}
$i\_attributeName$ verifies that  $conceptReference$ is a valid concept in the substrate and
interprets it as a set of (exactly one) $ATTRIBUTE$

$i\_attributeSubject$ interprets the constraintOperator, if any in the context of the attribute name and
interprets it as a set of $ATTRIBUTE$s

\textbf{Question:} Should we add any additional validation checks?
\begin{zed}
attributeName == conceptReference \\
\also
attributeOperator ==  \{ descendantOrSelfOf , descendantOf \} \\
attributeSubject == \optional[attributeOperator] \cross attributeName 
\end{zed}

\begin{gendef}
   i\_attributeName : Substrate \pfun attributeName \pfun Result \\
   i\_attributeSubject : Substrate \pfun attributeSubject \pfun Result \\
\where
   \forall ss : Substrate; an : attributeName @ i\_attributeName~ss~an = \\
\t1 i\_conceptReference~ss~an \\
\also
   \forall ss : Substrate; as : attributeSubject @ i\_attributeSubject~ss~as = \\
\t1 i\_constraintOperator~ss~(first~as)~(i\_attributeName~ss~(second~as)) \\
\end{gendef}
\subsection{Attribute}
\spec{attribute} consists of an optional \spec{cardinality} and an \spec{attributeConstraint}.
\begin{zed}
unlimitedNat ::= num \ldata \nat \rdata | many \\
cardinality == \nat \cross unlimitedNat \\
\end{zed}
\begin{schema}{attribute}
   card : \optional[cardinality] \\
   attw : attributeConstraint
\end{schema}

$attributeConstraint$ is either an attribute expression constraint or a concrete value constraint.
\begin{zed}
attributeConstraint ::= aec \ldata attributeExpressionConstraint \rdata | \\
\t2 acvc \ldata attributeConcreteValueConstraint \rdata \\
\end{zed}

\spec{attributeExpressionEonstraint} is a combination of a subject constraint (target if reverse flag is true) and an
expression constraint value whose interpretation yields a set of SCTID's that filter the target (subject if reverse flag).
\begin{zed}
[reverseFlag] 
\end{zed}
\begin{schema}{attributeExpressionConstraint}
   a : attributeSubject \\
   rf : \optional[reverseFlag] \\
   cs : expressionConstraintValue
\end{schema}

A concrete value constraint is the combination of a subject constraint and a comparison operator/concrete value 
whose interpretation yields a set of subject ids.  The intersection of the subject and concrete value interpretation
is the interpretation of \spec{attributeConcreteValueConstraint}
\begin{zed}
comparisonOperator ::= eq | neq | gt | ge | lt | le 
\end{zed}
\begin{schema}{attributeConcreteValueConstraint}
   a : attributeSubject \\
   op : comparisonOperator \\
   v : concreteValue
\end{schema}

The interpretation of an attribute is the interpretation of the cardinality applied against the
underlying attribute constraint, producing a set of SCTID's or an error condition

The interpretation of an attribute constraint is the interpretation of either the attribute expression
constraint or the concrete expression constraint that produces a set of Quads or an error condition.

The actual interpretations if attribute expression and concrete value are in Section \ref{sect:substrate}
\begin{gendef}
   i\_attribute : \\
\t2 Substrate \pfun attribute \pfun Result \\
   i\_attributeConstraint : \\
\t2 Substrate \pfun attributeConstraint \pfun Quads \\
   i\_attributeExpressionConstraint : \\
\t2 Substrate \pfun attributeExpressionConstraint \pfun Quads \\
   i\_attributeConcreteValueConstraint : \\
\t2 Substrate \pfun attributeConcreteValueConstraint \pfun Quads \\
\where
\forall ss : Substrate; a : attribute @ \\
\t1 i\_attribute~ss~a =  i\_cardinality~a.card~(i\_attributeConstraint~ss~a.attw) \\
\also
\forall ss :Substrate; aw : attributeConstraint @ i\_attributeConstraint~ss~aw = \\
\t1 \IF aec \inv aw \in attributeExpressionConstraint \\
\t2  \THEN i\_attributeExpressionConstraint~ss~(aec \inv aw) \\
\t1 \ELSE \IF acvc \inv aw \in attributeConcreteValueConstraint \\
\t2  \THEN i\_attributeConcreteValueConstraint~ss~(acvc \inv aw) \\
\t1 \ELSE qerror~ unknownOperation
 \also
\forall ss : Substrate; aec : attributeExpressionConstraint; eca : expressionConstraintArgs | \\
\t1 eca.atts = i\_attributeSubject~ss~aec.a \land \\
\t1 eca.rf = aec.rf \land \\
\t1 eca.subjOrTarg = i\_expressionConstraintValue~ss~aec.cs @ \\
\t1 i\_attributeExpressionConstraint~ss~aec = i\_attributeExpression~ss~eca
\also 
\forall ss : Substrate; awc : attributeConcreteValueConstraint; aca : concreteConstraintArgs | \\
\t1 aca.atts = i\_attributeSubject~ss~awc.a \land \\
\t1 aca.op =awc.op \land \\
\t1 aca.t = awc.v @ \\
\t1 i\_attributeConcreteValueConstraint~ss~awc = i\_concreteAttributeConstraint~ss~aca \\
\end{gendef}

\subsection{AttributeSet and AttributeGroup}
An \spec{attributeGroup} is an \spec{attributeSet}.  An \spec{attributeSet} consists of a sequence of one or more attribute constraints joined by \spec{binaryOperator}s.


\begin{zed}
binaryOperator  ::= conjunction | disjunction | exclusion \\
attributeGroup == attributeSet \\
attributeSet == attribute \cross \seq (binaryOperator \cross attribute) 
\end{zed}

\begin{gendef}
   i\_attributeGroup : Substrate \pfun attributeGroup \pfun Result 
\also
   i\_attributeSet : Substrate \pfun attributeSet \pfun Result 
\where
\forall ss : Substrate; ag : attributeGroup @ i\_attributeGroup~ss~ag = \\
\t1 i\_attributeSet~ss~ag
\also
\forall ss : Substrate; a: attributeSet @ i\_attributeSet~ss~a = \\
\t1 result~(evalCmpndAtt~ss~(i\_groupedAttribute~ss~(first~a))~(second~a))
\end{gendef}

\subsection{Compound attribute evaluation}
The left-to-right evaluation of \spec{attributeSet}.  The interpretation takes a $lhs$ as 
a function from $SCTID$ to $GROUP$ and a $rhs$ which is sequence of operator/attribute
tuples and recursively interprets the $lhs$ and interpretation of the head of the $rhs$.

\begin{gendef}
   evalCmpndAtt : \\
\t2 Substrate \fun IDGroups \fun \seq (binaryOperator \cross attribute) \fun IDGroups
\also
   gintersect, gunion, gminus, gfirstError : \\
\t2 IDGroups \fun IDGroups \fun IDGroups \\
\where
   \forall ss : Substrate; lhs: IDGroups; rhs: \seq (binaryOperator \cross attribute) @ \\
  evalCmpndAtt~ss~lhs~rhs = \\
 \IF rhs = \langle \rangle \\
\t1 \THEN lhs \\
\ELSE \IF first~(head~rhs) = conjunction \\
\THEN  evalCmpndAtt~ss~(gintersect~ lhs (i\_groupedAttribute~ss~(second~(head~rhs))))~(tail~rhs) \\
 \ELSE \IF first~(head~rhs)  = disjunction \\
\THEN  evalCmpndAtt~ss~(gunion~ lhs (i\_groupedAttribute~ss~(second~(head~rhs))))~(tail~rhs) \\
 \ELSE \IF first~(head~rhs)  = exclusion \\
\THEN  evalCmpndAtt~ss~(gminus~ lhs (i\_groupedAttribute~ss~(second~(head~rhs))))~(tail~rhs) \\
 \ELSE gerror~ unknownOperation
\also
   \forall a, b, r : IDGroups | \\
\t1 r = \IF gerror \inv a \in ERROR \lor gerror \inv b \in ERROR \THEN gfirstError~a~b \\
\t1 \ELSE gv ~(gv \inv a \cap gv \inv b) @ \\
\t1 gintersect~a~b=r
\also
   \forall a, b, r : IDGroups | \\
\t1 r = \IF gerror \inv a \in ERROR \lor gerror \inv b \in ERROR \THEN gfirstError~a~b \\
\t1 \ELSE gv ~(gv \inv a \cup gv \inv b) @ \\
\t1 gunion~a~b=r
\also
   \forall a, b, r : IDGroups | \\
\t1 r = \IF gerror \inv a \in ERROR \lor gerror \inv b \in ERROR \THEN gfirstError~a~b \\
\t1 \ELSE gv ~(gv \inv a \setminus gv \inv b) @ \\
\t1 gminus~a~b=r
\end{gendef}
\begin{gendef}
   i\_groupedAttribute : \\
\t2 Substrate \fun attribute \fun IDGroups
\where
\forall ss : Substrate; a : attribute @ \\
\t1 i\_groupedAttribute~ss~a =  i\_groupCardinality~(i\_attributeConstraint~ss~a.attw)~a.card \\
\end{gendef}

\subsection{Group Cardinality}
The interpretation of cardinality within a group impose additional constraints:
\begin{itemize}[noitemsep,nolistsep]
\item{$[0\upto~n]$} -- the set of all substrate concept codes that have at least one group (entry) in the substrate relationships and,
at most n matching entries in the same group
\item{$[0\upto0]$} -- the set of all substrate concept codes that have at least one group (entry) in the substrate relationships and \emph{no} matching entries 
\item{$[1..*]$} -- (default) at least one matching entry in the substrate relationships
\item{$[m_1\upto~n_1] op [m_2\upto~n_2] ... $} -- set of substrate concept codes where there exists at least one group where all conditions are simultaneously true
\end{itemize}

The interpretation of a grouped cardinality is a function from a set of SCTID's to the groups in which they were qualified.

The algorithm below partitions the input set of Quads by group and validates the cardinality on a per-group basis.  Groups that
pass are returned

\textbf{TODO:} This assumes that q.t is always type object. It doesn't say what to do if it is concrete
\textbf{TODO:} the $gresult$ function seems to express what is described below more simply
\begin{gendef}
   i\_groupCardinality : \\
\t2 Quads \fun \optional[cardinality] \fun IDGroups
\where
   \forall quads : Quads; oc : \optional[cardinality]; uniqueGroups : \power GROUP; \\
\t2 quadsByGroup : GROUP \pfun \power Quad |  \\
\t1    uniqueGroups = \{q : qids~quads @ q.g\}  \land \\
\t1    quadsByGroup = \{g: uniqueGroups; q : \power Quad | \\
\t2 q = \{e: qids~quads | e.g = g\}  @ g \mapsto (evalCardinality~oc~q) \} @ \\
i\_groupCardinality~quads~oc = \\
\t1 gv~ \{sctid : SCTID; groups : \power GROUP | sctid \in \{q : \bigcup (\ran quadsByGroup) @ \\
\t2  \IF qidd~quads = subjects \THEN q.s \ELSE object \inv q.t \} \land \\
\t1 groups = \{g: \dom quadsByGroup | (\exists q: quadsByGroup~g @ \\
\t2 sctid = \IF qidd~quads = subjects \THEN q.s \ELSE object \inv q.t) \} @ \\
\t2 sctid \mapsto groups \}
\end{gendef}

\subsection{Cardinality}
\textbf{Interpretation:}
$cardinality$ is tested against a set of quads with the following rules:
\begin{enumerate}[noitemsep,nolistsep]
\item Errors are propagated
\item No cardinality or passing cardinality returns  the subjects / targets of the set of quads
\item Otherwise return an empty set
\end{enumerate}
\begin{gendef}
   i\_cardinality :  \\
\t2 \optional[cardinality] \fun Quads \fun  Result
\where
   \forall oc: \optional[cardinality]; qr : Quads  @ \\
i\_cardinality~oc~qr = \\
\t1 \IF qerror \inv qr \in ERROR \THEN result~(gresult~qr) \\
\t1 \ELSE  result~(gresult~(qv~(evalCardinality~oc~(qids~qr), qidd~qr))) 
\end{gendef}

\paragraph{evalCardinality}
Evaluate the cardinality of a set, returning the set if it meets the constraints, otherwise return the empty set.

\begin{gendef}
   evalCardinality : \optional[cardinality] \fun \power Quad \fun \power Quad
\where
   \forall oc : \optional[cardinality]; s : \power Quad @ evalCardinality~oc~s = \\
\t1 \IF \#oc = 0 \THEN s \\
\t1 \ELSE \IF (\#s \geq first~(head~oc)) \land \\
\t2 (second~(head~oc) = many \lor num \inv (second~(head~oc)) \leq \#s) \\
\t1 \THEN s \\
\t1 \ELSE  \emptyset
\end{gendef}

\section{Substrate Interpretations}
\label{sect:substrate}
This section defines the interpretations that are realized against the substrate. 

\subsection{AttributeExpressionConstraint}
$expressionConstraintArgs$ carries the arguments necessary to evaluate an attribute expression
\begin{itemize}[noitemsep,nolistsep]
\item{\textbf{rf}}  -- If present, return subjects matching attribute/target subjects
\item{\textbf{subjOrTarg}} -- Set of subject or target SCTIDS (or error)
\item{\textbf{atts}}  -- Set of attributes to evaluate
\end{itemize}

\begin{schema}{expressionConstraintArgs}
   rf : \optional[reverseFlag] \\
   subjOrTarg : Result \\
   atts : Result \\
\end{schema}

Evaluate an attribute expression, returning the set of quads in the substrate relationship table
with the supplied subject / attribute if $rf$ is
absent and attribute / target if $rf$ is present.  The interpretation returns an error there is
an error in either the subject/targets or attributes.
\textbf{TODO:}  We don't say what to do if the target (t) is concrete
\begin{gendef}
   i\_attributeExpression : \\ 
\t2 Substrate \fun expressionConstraintArgs \fun Quads
\where
   \forall ss : Substrate;  args : expressionConstraintArgs; \\
\t1 sti: \power TARGET; atts : \power ATTRIBUTE | \\
   sti = ok \inv args.subjOrTarg \land atts = ok \inv args.atts @ \\
   i\_attributeExpression~ss~args = \\
\t1 \IF error \inv (bigunion \{args.subjOrTarg, args.atts \}) \in ERROR \\
\t1 \THEN \\
\t2 qfirstError \{args.subjOrTarg, args.atts\} \\
\t1 \ELSE \IF \lnot (sti \cup  atts) \subseteq ss.c \\
\t1 \THEN \\
\t2 qerror~  unknownConceptReference \\
\t1 \ELSE \IF \# args.rf = 0 \\
\t1 \THEN \\
\t2 qv (\{ s: SUBJECT; t: sti; a: atts; g: GROUP; re : ss.r |\\
\t3 re.t = t \land re.a = a @ re \} , subjects) \\
\t1 \ELSE \\
\t2 qv  (\{ s: sti; a: atts; t : TARGET; g: GROUP; re : ss.r | \\
\t3 re.s = object \inv t \land re.a= a @ re \} , targets) \\
\end{gendef}



\subsection{ConcreteAttributeConstraint}
\begin{verbatim}
concreteValue =  QM stringValue QM / "#" numericValue 
stringValue = 1*(anyNonEscapedChar / escapedChar)
numericValue = decimalValue / integerValue
integerValue = ( ["-"/"+"] digitNonZero *digit ) / zero
\end{verbatim}
The mechanism for interpreting $concreteValue$ is not fully specified at this point. 
Much of the rest of the machinery is focused around interpreting constraints in the context
of quads - subject, attribute, target and group, so the function is currently defined as returning
a $Quads$, but another type or interpretation may be in order.
\begin{zed}
concreteValue ::= stringValue | integerValue | realValue 
\end{zed}

\paragraph{concreteConstraintArgs}  The arguments to the concrete value function.
\begin{itemize}[noitemsep,nolistsep]
\item \textbf{atts} -- list of attributes to test
\item \textbf{op} -- operator
\item \textbf{t} -- value to test against
\end{itemize}
\noindent 
\textbf{Note:} $reverseFlag$ has no meaning for concrete constraints.

\begin{schema}{concreteConstraintArgs}
   atts : Result \\
   op : comparisonOperator \\
   t : concreteValue
\end{schema}

\begin{gendef}
  i\_concreteAttributeConstraint : \\
\t2 Substrate \fun concreteConstraintArgs \fun Quads
\end{gendef}


\subsection{ConstraintOperator}
\begin{verbatim}
constraintOperator = 
         descendantOrSelfOf / descendantOf /  ancestorOrSelfOf / ancestorOf 
\end{verbatim}

\noindent
\textbf{Interpretation:}  Apply the substrate descendants ($descs$) or ancestors ($ancs$) function to a set of SCTID's in the supplied
$Result$.  Error conditions are propagated.


\begin{gendef}
   i\_constraintOperator : \\
\t2 Substrate \pfun \optional[constraintOperator] \pfun Result \pfun Result
\also
   completeFun : (SCTID \pfun \power SCTID) \fun SCTID \fun \power SCTID \\
\where
	\forall ss : Substrate; oco : \optional[constraintOperator]; refset : Result @ \\
i\_constraintOperator~ss~oco~refset = \\
\t1 \IF error \inv refset \in ERROR \lor \# oco = 0 \\
\t2 \THEN refset \\
\t1 \ELSE \IF head~oco = descendantOrSelfOf~ \\
\t2 \THEN ok (\bigcup \{id : ids~refset @ completeFun~ss.descs~id \cup \{id\}~\}) \\
\t1 \ELSE \IF head~oco = descendantOf~ \\
\t2 \THEN ok  (\bigcup \{id : ids~refset @ completeFun~ss.descs~id \setminus \{id\}~\}) \\
\t1 \ELSE \IF head~oco = ancestorOrSelfOf~ \\
\t2 \THEN  ok (\bigcup \{id : ids~refset @ completeFun~ss.ancs~id \cup \{id\}~\}) \\
\t1 \ELSE \IF head~oco = ancestorOf~ \\
\t2 \THEN ok (\bigcup \{id : ids~refset @ completeFun~ ss.ancs~id \setminus \{id\}~\}) \\
\t1 \ELSE error~ unknownOperation
\also
   \forall f : (SCTID \pfun \power SCTID); id : SCTID @ completeFun~f~id = \\
\t1\IF id \in \dom f \THEN f~id \ELSE \emptyset 
\end{gendef}


\subsection{FocusConcept}

\begin{verbatim}
focusConcept = [memberOf] conceptReference
\end{verbatim}

\textbf{Interpretation:}  focusConcept is interpreted as the interpretation of conceptReference itself or, if memberOf is specified, the interpretation of the memberOf function
applied to the conceptReference

\begin{zed}
focusConcept ::= mo \ldata conceptReference \rdata | cr \ldata conceptReference \rdata
\end{zed}

\begin{gendef}
   i\_focusConcept : Substrate \fun focusConcept \fun Result
\where
   \forall ss : Substrate; fc : focusConcept @ \\
i\_focusConcept~ss~fc = \\
\t1 \IF cr \inv fc \in conceptReference \\
\t2 \THEN i\_conceptReference~ss~(cr \inv fc) \\
\t1 \ELSE \IF mo \inv fc \in conceptReference \\
\t2 \THEN i\_memberOf~ss~(mo \inv fc) \\
\t1 \ELSE error~ unknownOperation
\end{gendef}

\subsubsection{memberOf}
\textbf{Interpretation:} memberOf is interpreted as application $refset$ function to the conceptReference SCTID or an error if the SCTID isn't in the domain of the $refset$ function.

\begin{gendef}
   i\_memberOf : Substrate \fun conceptReference \fun Result
\where
   \forall ss : Substrate; cr : conceptReference @ \\
i\_memberOf~ss~cr = \\
\t1 (\LET sctid == toSCTID~cr @ \\
\t2 \IF sctid \notin \dom ss.refset \THEN error~unknownRefsetId \\
\t1 \ELSE ok~(ss.refset~sctid))
\end{gendef}

\subsection{ConceptReference}
\begin{verbatim}
conceptReference = conceptId [ "|" Term "|"]
conceptId = sctId
\end{verbatim}
\textbf{Interpretation:}  conceptReference is interpreted as $SCTID$ if it is a member the list of concepts, $c$
in the substrate, otherwise as an $error$.

\begin{zed}
[conceptReference]
\end{zed}

\begin{gendef}
   toSCTID : conceptReference \fun SCTID \\
   i\_conceptReference : Substrate \fun conceptReference \fun Result \\
\where
   \forall ss: Substrate; c : conceptReference @ i\_conceptReference~ss~c = \\
\t1 \IF (toSCTID~ c) \in ss.c \THEN ok \{(toSCTID~ c)\} \\
\t1 \ELSE error~ unknownConceptReference
\end{gendef}

\section{Glue and Helper Functions}
This section carries various type transformations and error checking functions

\subsection{Types}

\begin{itemize}[noitemsep,nolistsep]
\item \textbf{direction} -- an indicator whether a collection of quads was determined as subject to target ($subjects$) or target to subject ($targets$)
\item \textbf{Quads} --  a collection of $Quad$s or an error condition. If it is a collection $Quad$s, it also carries
a direction indicator that determines whether it represents a set of subjects or targets. 
\item \textbf{IDGroups} -- a map from $SCTID$s to the $GROUP$ they were in when they passed if successful, otherwise an error indication.
\end{itemize}

\begin{zed}
direction ::= subjects | targets \\
Quads ::= qv \ldata \power Quad \cross direction \rdata | qerror \ldata ERROR \rdata \\
\also
IDGroups ::= gv \ldata SCTID \pfun \power GROUP \rdata | gerror \ldata ERROR \rdata
\end{zed}

\subsection{Result transformations}
\begin{itemize}[noitemsep,nolistsep]
\item \textbf{ids} -- return the set of $SCTID$s in a result or the empty set if there is an error
\item \textbf{qids} -- return the set of $Quads$ in a quads result or an empty set if there is an error
\item \textbf{qidd} -- return the direction of a $Quads$ result.  Undefined if error
\item \textbf{gids} -- return the $SCTID$ to group map in an id group or an empty map if there is error
\item \textbf{gresult} -- convert a set of quads int a set of id groups
\item \textbf{result} -- convert a set of id groups into a simple result.
\end{itemize}
\begin{gendef}
   ids: Result \fun \power SCTID \\
   qids: Quads \fun \power Quad  \\
   qidd: Quads \pfun direction \\
   gids: IDGroups \fun SCTID \fun \power GROUP \\
   gresult: Quads \fun IDGroups \\
   result: IDGroups \fun Result \\
\where
   \forall r: Result @ ids~r = \\
\t1 \IF error \inv r \in ERROR \THEN \emptyset \\
\t1 \ELSE ok \inv r
\also
   \forall q : Quads @ qids~q = \\
\t1 \IF qerror \inv q \in ERROR \THEN \emptyset \\
\t1 \ELSE first~(qv \inv q)
\also
   \forall q : Quads @ qidd~q = \\
\t1 second~(qv \inv q)
\also
   \forall g : IDGroups @ gids~g = \\
\t1 \IF gerror \inv g \in ERROR \THEN \emptyset \\
\t1 \ELSE gv \inv g
\also
   \forall q : Quads @ gresult~q = \\
\t1 \IF qerror  \inv q \in ERROR \THEN gerror (qerror \inv q) \\
\t1 \ELSE \IF qidd~q = subjects \\
\t2 \THEN gv~\{s : SCTID | (\exists qr : qids~q @ s = qr.s) @ \\
\t2 s \mapsto \{qr : qids~q @ qr.g\} \} \\
\t1 \ELSE \\
\t2 gv~\{t : SCTID | (\exists qr : qids~q @ t = object \inv qr.t ) @ \\
\t2 t \mapsto \{qr : qids~q @ qr.g\} \} 
\also
   \forall g : IDGroups @ result~g = \\
\t1 \IF gerror \inv g \in ERROR \THEN error (gerror \inv g) \\
\t1 \ELSE ok (\dom (gv \inv g))
\end{gendef}



\paragraph{}
Definition of the various functions that are performed on the result type. \\
\begin{itemize}[noitemsep,nolistsep]
\item \textbf{firstError} -- take a set of $Result$s with one or more errors and return an aggregation / summary as a $Result$.  (Not fully defined)
\item \textbf{qfirstError} -- take a set of $Result$s with one or more errors and return an aggregation / summary as a $Quads$ instance. (not fully defined)
\end{itemize}

\begin{itemize}[noitemsep]
\item \textbf{union} -- return the union of two $Result$ $SCTID$s or $ERROR$ if either of them have an error.
\item \textbf{intersect} -- return the intersection of two  $Result$ $SCTID$s or $ERROR$ if either of them have an error.
\item \textbf{minus} -- return the set of $SCTID$s in the first set of results that are not in the second or $ERROR$ if either of them have an error.
\item \textbf{bigunion} -- return the union of a set $Result$ $SCTID$s or $ERROR$ if any of the results in the set have an error.
\item \textbf{bigintersect} -- return the intersection of a set $Result$ $SCTID$s or $ERROR$ if any of the results in the set have an error.
\end{itemize}


$firstError$ is not fully defined -- it takes a set of results with one or more errors
and returns an aggregation of all of the errors.
\begin{gendef}
   union, intersect, minus : Result \fun Result \fun Result \\
   bigunion, bigintersect : \power Result \fun Result \\
   firstError : \power Result \pfun Result \\
   qfirstError : \power Result \pfun Quads 
\where
   \forall x,y : Result @ union~x~y = \\
\t1 \IF error \inv x \in ERROR \THEN x \\
\t1 \ELSE \IF error \inv y \in ERROR \THEN y \\
\t1 \ELSE ok~((ok \inv x) \cup (ok \inv y))
\also
   \forall x,y : Result @ intersect~x~y = \\
\t1 \IF error \inv x \in ERROR \THEN x \\
\t1 \ELSE \IF error \inv y \in ERROR \THEN y \\
\t1 \ELSE ok~((ok \inv x) \cap (ok \inv y))
\also
   \forall x,y : Result @ minus~x~y = \\
\t1 \IF error \inv x \in ERROR \THEN x \\
\t1 \ELSE \IF error \inv y \in ERROR \THEN y \\
\t1 \ELSE ok~((ok \inv x) \setminus (ok \inv y))
\also
  \forall rs : \power Result @ bigunion~rs = \\
\t1 \IF \exists r : rs @ error \inv r \in ERROR \THEN firstError~ rs \\
\t1 \ELSE ok~(\bigcup \{r : rs @ ids~r\})
\also
  \forall rs : \power Result @ bigintersect~rs = \\
\t1 \IF \exists r : rs @ error \inv r \in ERROR \THEN firstError~ rs \\
\t1 \ELSE ok~(\bigcap \{r : rs @ ids~r\})
\end{gendef}

   

\section{Appendix 1}
Representing optional elements of type $T$.  Representing it as a sequence allows us to
determine absence by $\#T = 0$ and the value by $head~T$. 

\begin{zed} 
  \optional[T] == \{ s : \seq T \mid \# s \leq 1 \} \\
\end{zed}

\end{document}


   

