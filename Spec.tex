\documentclass{article}
\usepackage{enumitem}
\usepackage{zed}
\usepackage{verbatim}
\usepackage{framed}

\def\spec#1{{\tt \small \textsc{{#1}} }}
\def\req#1{{\sf {{\it #1}} }}
\def\bnf#1{{\scriptsize {{#1}} }}
\def\desc#1{{\small \textsl{{#1}} }}


\raggedbottom
\include{uml_style}

\title{A Declarative Semantics for SNOMED~CT Expression Constraints}

\begin{document}
\maketitle
\tableofcontents
\pagebreak
% =================================  Data types and Substrate ========================
\section{Data Types}
\subsection{Atomic Data Types}
This section identifies the atomic data types that are assumed for the rest of this specification.  These types
are defined as lexical components in the specification.
\begin{framed}
\noindent
\bnf{sctId = digitNonZero 5*17( digit )} \\
\bnf{term = 1*nonwsNonPipe *( 1*SP 1*nonwsNonPipe )} \\
\bnf{numericValue =  QM stringValue QM / ``\#'' numericValue ( decimalValue / integerValue)} \\
\bnf{stringValue =  QM 1*(anyNonEscapedChar / escapedChar) QM} \\
\bnf{integerValue = ( [``-''/``+''] digitNonZero *digit ) / zero} \\
\bnf{decimalValue = integerValue ``.'' 1*digit} \\
\bnf{nonNegativeIntegerValue = (digitNonZero *digit ) / zero}
\end{framed}
\begin{itemize}[noitemsep]
\item \spec{sctId} -- \desc{A SNOMED CT id is used to represent an attribute id or a concept id.  The initial digit may not be zero. The smallest number of digits is six, and the maximum is 18.}
\item \spec{term} --  \desc{The term must be the term from a SNOMED CT description that is associated with the concept identified by the preceding concept identifier. For example, the term could be the preferred description, or the preferred description associated with a particular translation. The term may include valid UTF-8 characters except for the pipe ``\textbar'' character. The term begins with the first non-whitespace character following the starting ``\textbar'' character and ends with the last non-whitespace character preceding the next ``\textbar'' character.}
\item \spec{stringValue} -- \desc{A string value includes one or more of any printable ASCII characters enclosed in quotation marks. Quotes and backslash characters within the string must be preceded by the escape character (``\textbackslash'').}
\item \spec{$\num$} -- built-in $Z$ equivalent of \spec{integerValue}. \desc{An integer may be positive, negative or zero. Positive integers optionally start with a plus sign (``+''), followed by a non-zero digit followed by zero to many additional digits. Negative integers begin with a minus sign (``-'') followed by a non-zero digit and zero to many additional digits.}
\item \spec{decimalValue} --  \desc{A decimal value starts with an integer. This is followed by a decimal point and one to many digits.}
\item \spec{$\nat$} -- built-in $Z$ equivalent of \spec{nonNegativeIntegerValue}
\item \spec{groupId} -- a role group identifier.  (Not explicated in the specification, but needed)
\end{itemize}

\begin{zed}
[sctId, term, decimalValue, stringValue, groupId] 
\end{zed}


We specifically define some well known identifiers: the $is\_a$ attribute, the $zero\_group$ and  $attribute\_concept$, and $refset\_concept$ the parents of all attributes and all refsets respectively.
\begin{axdef}
is\_a : sctId \\
zero\_group : groupId \\
attribute\_concept : sctId \\
refset\_concept : sctId
\end{axdef}

\subsection{Composite Data Types}
$concreteValue$ is in anticipation of the enhanced specification that includes target strings, integers or decimals.

\begin{itemize}[noitemsep,nolistsep]
\item \textbf{concreteValue} -- a string, integer or decimal literal
\item \textbf{target} -- the target of a relationship that is either an $sctId$ or a $concreteValue$
\end{itemize}

\begin{zed}
concreteValue ::= \\
\t1 cv\_string \ldata stringValue \rdata | cv\_integer \ldata \num \rdata | cv\_decimal \ldata decimalValue \rdata
\also
target ::= t\_sctid \ldata sctId \rdata | t\_concrete \ldata concreteValue \rdata
\end{zed}
\pagebreak
\section{The Substrate}
A substrate represents the context of an interpretation.  
\subsection{Substrate Components}
\subsubsection{Quad}
Relationships in the substrate are represented a 4 element tuples or ``quads'' which consist of a source, attribute, target and role group identifier.  The $is\_a$ attribute may
only appear in the zero group, and the target of an $is\_a$ attribute must be a $sctId$ (not a $concreteValue$)

\begin{schema}{Quad}
   s : sctId \\
   a : sctId \\
   t : target \\
   g : groupId
\where
   a = is\_a \implies (g = zero\_group \land t \in \ran t\_sctid)
\end{schema}

\subsubsection{conceptReference}
The root of the expression constraint language is concept references:
\begin{itemize}
\item \spec{conceptReference} -- \desc{A conceptReference is represented by a ConceptId optionally followed by a term enclosed by a pair of ``\textbar'' characters. Whitespace before or after the ConceptId is ignored as is any whitespace between the initial ``\textbar'' characters and the first non-whitespace character in the term or between the last non-whitespace character and before second ``\textbar'' character.} \spec{term} is ignored for the purposes of interpretation.  
\item \spec{conceptId} -- \desc{The ConceptId must be a valid SNOMED CT identifier for a concept. The initial digit may not be zero. The smallest number of digits is six, and the maximum is 18.}
\item \spec{attributeName} -- \desc{The attribute name is the name of an attribute (or relationship type) to which a value is applied to refine the meaning of a containing expression. The attribute name is represented in the same way as other concept references. If the attribute name is not known then a wild card may be used to represent any attribute concept in the given substrate.}
\end{itemize}
\begin{framed}
\noindent
\bnf{conceptReference = conceptId [ws ``\textbar'' ws term ws ``\textbar'']} \\
\bnf{conceptId = sctId} \\
\bnf{attributeName = conceptReference / wildCard}
\end{framed}

\begin{zed}
conceptReference == conceptId \cross \optional[term] \\
conceptId == sctId \\
attributeName ::= ancr \ldata conceptReference \rdata | anwc
\end{zed}

\subsection{Substrate}
\subsubsection{Substrate Definition}
A substrate consists of:

\begin{itemize}[noitemsep,nolistsep]
\item{\textbf{concepts}} The set of $sctId$s (concepts) that are considered valid in the context of the substrate.  
\item{\textbf{relationships}} A set of relationship quads (source, attribute, target, group)
\item{\textbf{parentsOf}}  A function from an sctId to its asserted and inferred parents
\item{\textbf{equivalent\_concepts}} A function from an sctId to the set of sctId's that have been determined to be equivalent to it. 
 \item{\textbf{refsets}} The reference sets within the context of the substrate whose members are members are concept identifiers (i.e. are in $concepts$).  While not formally spelled out in this specification, it is assumed that the typical reference set function would be returning a subset of the $refsetId$ / $referencedComponentId$ tuples represented in one or more RF2 Refset Distribution tables.
\end{itemize}
\paragraph{}

The following functions can be computed from the basic set above
\begin{itemize}[noitemsep,nolistsep]
\item{\textbf{childrenOf}} The inverse of the parentsOf function
\item{\textbf{descendants}} The transitive closure of the childrenOf function
\item{\textbf{ancestors}} The transitive closure of the parentsOf function
\end{itemize}

\paragraph{}

A substrate also implements three functions:
\begin{itemize}[noitemsep,nolistsep]
\item{\textbf{i\_conceptReference}} The interpretation of a concept reference.  This function can return a (possibly empty) set of sctId's or an error.
\item{\textbf{i\_attributeName}} The interpretation of an attribute name.  This function can return a (possibly empty) set of sctId's or an error.
\item{\textbf{i\_refsetId}} The interpretation of a refset identifier.  This function can return a (possibly empty) set of sctId's or an error.
\end{itemize}
\paragraph{}
The formal definition of substrate follows. The expressions below assert that:
\begin{enumerate}[noitemsep,nolistsep]
\item All $relationship$ sources, attributes and sctId targets are in $concepts$.
\item There is a $parentsOf$ entry for every substrate $concept$.
\item Every sctId that can be returned by the $parentsOf$ function is a $concept$.
\item Every $is\_a$ relationship entry is represented in the $parentsOf$ function. Note that there can be additional entries represented in the $parentsOf$ function that aren't in the relationships table.
\item There is an $equivalent\_concepts$ assertion for every substrate $concept$.
\item The $equivalent\_concepts$ function is reflexive (i.e. every concept is equivalent to itself).
\item All equivalent concepts are in $concepts$.
\item If two concepts (c2 and c2) are equivalent, then they:
\begin{itemize}[noitemsep,nolistsep]
\item Have the same parents
\item Appear the subject, attribute and object of the same set of relationships
\item Appear in the domain of the same set of refsets
\item Both appear in the range of any refset that one appears in
\end{itemize}
\item Every refset is a substrate $concept$
\item Every member of a refset is a substrate $concept$
\item $childrenOf$ is the inverse of $parentsOf$, where any concept that doesn't appear a parent has no (the emptyset) children.
\item $descendants$ is the transitive closure of the $childrenOf$ function
\item $ancestors$ is the transitive closure of the $parentsOf$ function
\item No concept can be its own ancestor (or, by inference, descendant)
\item The $i\_conceptReference, i\_attributeName$ and $i\_refsetId$ functions are defined for all possible $conceptReferences$ and $attributeNames$ (because they are complete functions).
\item All $sctId's$ that are produced by the The $i\_conceptReference, i\_attributeName$ and $i\_refsetId$ functions are substrate $concepts$.
\end{enumerate}


\begin{schema}{Substrate}
   concepts : \power sctId \\
   relationships : \power Quad  \\
   parentsOf : sctId \pfun \power sctId \\
   equivalent\_concepts : sctId \pfun \power sctId \\
   refsets : sctId \pfun \power sctId 
\also
   childrenOf : sctId \pfun \power sctId \\
   descendants : sctId \pfun \power sctId \\
   ancestors : sctId \pfun \power sctId \\
\also
   groups : \power groupId \\
   subjects : \power sctId \\
   targets : \power target
\also
   i\_conceptReference : conceptReference \fun Sctids\_or\_Error \\
   i\_attributeName : attributeName \fun Sctids\_or\_Error \\
   i\_refsetId : sctId \fun Sctids\_or\_Error
\where
   \forall rel : relationships @  rel.s \in concepts \land rel.a \in concepts \land \\
\t2 (rel.t \in \ran t\_sctid \implies t\_sctid \inv rel.t \in concepts)
\also
   \dom parentsOf = concepts \\
   \bigcup (\ran parentsOf) \subseteq concepts
\also
   \forall r : relationships @ r.a = is\_a \implies (t\_sctid \inv r.t) \in parentsOf~r.s
\also
   \dom equivalent\_concepts = concepts \\
   \bigcup (\ran equivalent\_concepts) \subseteq concepts \\
  \forall c : concepts @ c \in equivalent\_concepts~c \\
  \forall c1, c2 : concepts | c2 \in (equivalent\_concepts~c1) @ \\
\t2 parentsOf ~ c1 = parentsOf ~ c2 \land \\
\t2 \{r : relationships | r.s = c1\} = \{r : relationships | r.s = c2\} \land \\
\t2 \{r : relationships | r.a = c1\} = \{r : relationships | r.a = c2\} \land \\
\t2 \{r : relationships | t\_sctid \inv r.t = c1\} = \{r : relationships | t\_sctid \inv r.t = c2\} \land \\
\t2 c1 \in \dom refsets \iff c2 \in \dom refsets \land \\
\t2 c1 \in \dom refsets \implies refsets~c1 = refsets~c2 \land \\
\t2 (\forall rsd : \ran refsets @ c1 \in rsd \iff c2 \in rsd)
\also
   \dom refsets \subseteq concepts \\
   \bigcup (\ran refsets) \subseteq concepts
\also
    \dom childrenOf = concepts \\
    \forall s, t : concepts @ t \in parentsOf~s \iff s \in childrenOf~t  \\
    \forall c : concepts | c \notin \bigcup (\ran childrenOf) @ childrenOf~c = \emptyset \\
    \forall s : concepts @ \\
\t2 descendants~s = childrenOf~ s \cup \bigcup \{t : childrenOf~ s @ descendants~t\} \\
   \forall t : concepts @ \\
\t2 ancestors~t = parentsOf~ t \cup \bigcup \{s : parentsOf~ t @ ancestors~s\} \\
   \forall t : concepts @ t \notin ancestors~t
\also
   groups = \{r : relationships @ r.g \} \\
   subjects = \{r : relationships @ r.s \} \\
   targets = \{r : relationships @ r.t \}
\also
   \forall cr\_interp : \ran i\_conceptReference | cr\_interp \in \ran ok @ \\
\t2 result\_sctids~cr\_interp \subseteq concepts \\
   \forall att\_interp : \ran i\_attributeName | att\_interp \in \ran ok @ \\
\t2 result\_sctids~att\_interp \subseteq concepts \\
   \forall refset\_interp : \ran i\_refsetId | refset\_interp \in \ran ok @ \\
\t2 result\_sctids~refset\_interp \subseteq concepts 
\end{schema}

Implementations may choose to implement ``strict'' substrates, where additional rules apply or ``permissive'' substrates where rules are relaxed.
\subsubsection{Strict Substrate}
A \textbf{strict\_substrate} is a substrate where:
\begin{itemize}[noitemsep,nolistsep]
\item If a conceptReference is not in the substrate concepts it returns an error, otherwise the set of equivalent concepts
\item If an attribute name is a conceptReference and it is not in the substrate concepts or is not a descendant of the attribute\_concept it returns an error, otherwise the set of equivalent attributes.  If an
attribute name is a wild card, it returns all descendants of attribute\_concept
\item If a concept reference that is a target of a memberOf function is not in the substrate concepts or is not a descendant of the refset\_concept it returns an error, otherwise the set of equivalent refset identifiers
\end{itemize}

\begin{schema}{strict\_substrate}
    Substrate
 \where
    \forall cr : conceptReference @ i\_conceptReference~cr = \\
\t1 \IF first~cr \notin concepts \THEN error~unknownConceptReference \\
\t1 \ELSE ok~(equivalent\_concepts~(first~cr))
\also
   \forall an : attributeName @ i\_attributeName~an = \\
\IF ancr \inv an \in conceptReference \THEN \\
\t1   (\LET rslt == i\_conceptReference~(ancr \inv an) @ \\
\t2 \IF rslt \in \ran error \THEN rslt \\
\t2 \ELSE \IF result\_sctids~rslt \subseteq (descendants~attribute\_concept)  \\
\t3 \THEN rslt \\
\t2 \ELSE \\
\t3 error~unknownAttributeId) \\
\ELSE \\
\t1 ok~(descendants~attribute\_concept)
\also
  \forall rsid : sctId @ i\_refsetId~rsid = \\
\t1  \IF rsid \in descendants~refset\_concept  \\
\t2 \THEN ok~\{rsid\} \\
\t1 \ELSE error~unknownRefsetId
\end{schema}
     
 
 \subsubsection{Permissive Substrate}
 A \textbf{permissive\_substrate} never raises an error condition.  concept references that are not in the substrate are ``discarded'' (i.e. map to the empty set).  Any valid conceptReference may be used in the position of an attribute or a refset id.  The attributeName wild card returns the set of all possible concepts.
\begin{schema}{permissive\_substrate}
    Substrate
 \where
    \forall cr : conceptReference @ i\_conceptReference~cr = \\
\t1 \IF first~cr \notin concepts \THEN ok~ \emptyset \\
\t1 \ELSE ok~(equivalent\_concepts~(first~cr))
\also
   \forall an : attributeName @ i\_attributeName~an = \\
\IF ancr \inv an \in conceptReference \THEN \\
\t1 i\_conceptReference~(ancr \inv an) \\
\ELSE \\
\t1 ok~concepts \\
\also
  \forall rsid : sctId @ i\_refsetId~rsid = \\
\t1 \IF rsid \notin concepts \THEN ok~ \emptyset \\
\t1 \ELSE ok~(equivalent\_concepts~(rsid))
\end{schema}

% ================================= Chapter 3 Interpretations ========================
\pagebreak
\section{Interpretation of Expression Constraints}
An \spec{expressionConstraint} is interpreted in the context of a $Substrate$ and returns a set of $sctId$s or an error indicator.  

  
\subsection{Interpretation Output}
The result of applying a query against a substrate is either a (possibly empty) set of sctId's or an $ERROR$.  An $ERROR$ occurs when:
\begin{itemize}[noitemsep,nolistsep]
\item The interpretation of a conceptId is not a substrate $concept$
\item The interpretation of a relationship attribute is not a substrate $attributeId$
\item The interpretation of a reset is not a substrate $refsetId$
\end{itemize}


\begin{zed}  
ERROR ::= unknownConceptReference | unknownAttributeId | unknownRefsetId 
\also
Sctids\_or\_Error ::= ok \ldata \power sctId \rdata | error \ldata ERROR \rdata 
\end{zed}

Each interpretation that follows begins with a simplified version
of the language construct in the specification.  It then formally specifies the constructs that are used in the interpretation, followed by the interpretation itself. We start with the definition 
of $expressionConstraint$, which, once interpreted, returns either a set of sctIds or an error condition.
\subsection{expressionConstraint}

\begin{framed}
\desc{An expression constraint is either a refined expression constraint or an unrefined expression constraint.}
\end{framed}
\begin{framed}
\noindent
\bnf{expressionConstraint = ws ( refinedExpressionConstraint / unrefinedExpressionConstraint ) ws}
\end{framed}

The interpretation of an \spec{expressionConstraint} is the interpretation of either the  \spec{refinedExpressionConstraint} or the \\ \spec{unrefinedExpressionConstraint}.

\begin{zed}
expressionConstraint ::= \\
\t2 expcons\_refined \ldata refinedExpressionConstraint \rdata | \\
\t2 expcons\_unrefined \ldata unrefinedExpressionConstraint \rdata \\
\end{zed}


\begin{axdef}
   i\_expressionConstraint : \\
\t2 Substrate \fun expressionConstraint \fun Sctids\_or\_Error
\where
   \forall ss: Substrate; ec: expressionConstraint @ i\_expressionConstraint~ss~ec = \\
   \IF ec \in \ran expcons\_refined  \\
\THEN \\
\t1 i\_refinedExpressionConstraint~ss~(expcons\_refined \inv ec) \\
   \ELSE \\
\t1 i\_unrefinedExpressionConstraint~ss~(expcons\_unrefined \inv ec) 
\end{axdef}

\subsubsection{unrefinedExpressionConstraint}
\begin{framed}
\desc{An unrefined expression constraint is either compound or simple.}
\end{framed}
\begin{framed}
\noindent
\bnf{unrefinedExpressionConstraint = compoundExpressionConstraint / simpleExpressionConstraint}
\end{framed}

The interpretation of an \spec{unrefinedExpressionConstraint} is either the interpretation of a \spec{compoundExpressionConstraint} or a \spec{simpleExpressionConstraint}


\begin{zed}
unrefinedExpressionConstraint ::= \\
\t2 unrefined\_compound \ldata compoundExpressionConstraint \rdata | \\
\t2 unrefined\_simple \ldata simpleExpressionConstraint \rdata
\end{zed}
\begin{axdef}
   i\_unrefinedExpressionConstraint : \\
\t2 Substrate \fun unrefinedExpressionConstraint \fun Sctids\_or\_Error
\where
   \forall ss : Substrate; uec : unrefinedExpressionConstraint @  \\
   i\_unrefinedExpressionConstraint~ss~uec = \\
   \IF uec \in \ran unrefined\_compound \\
 \THEN \\
 \t1 i\_compoundExpressionConstraint~ss~(unrefined\_compound \inv uec) \\
\ELSE  \\
\t1 i\_simpleExpressionConstraint~ss~(unrefined\_simple \inv uec) 
\end{axdef}

\subsubsection{refinedExpressionConstraint}
\begin{framed}
\desc{A refined expression constraint starts with an unrefined expression constraint and adds a refinement. Refined expression constraints may optionally be placed in brackets.}
\end{framed}
\begin{framed}
\noindent
\bnf{refinedExpressionConstraint = unrefinedExpressionConstraint ws ``:'' ws refinement / ``('' ws refinedExpressionConstraint ws ``)''}
\end{framed}

The interpretation of \spec{refinedExpressionConstraint} is the \underline{intersection} of the interpretation of
the \spec{unrefinedExpressionConstraint} and the \spec{refinement}, both of which return a set of sctId's or
an error.  The second production defines \spec{refinedExpressionConstraint} in terms of itself and has no effect on the results.

\textit{Note:} The second declaration below ($refinedExpressionConstraint'$) is used to avoid circular definitions.

\begin{zed}
refinedExpressionConstraint == \\
\t2 unrefinedExpressionConstraint \cross refinement \\
[refinedExpressionConstraint']
\end{zed}

\begin{axdef}
   i\_refinedExpressionConstraint : \\
\t1 Substrate \fun refinedExpressionConstraint \fun Sctids\_or\_Error
\where
   \forall ss : Substrate; rec : refinedExpressionConstraint @ \\
  (\LET unref\_interp == (i\_unrefinedExpressionConstraint~ss~(first~rec)) @ \\
\t1   i\_refinedExpressionConstraint~ss~rec = \\
\t2 intersect~unref\_interp (i\_refinement~ss~(second~rec)))
\end{axdef}

Duplicate signature for recursive definitions
\begin{axdef}
   i\_refinedExpressionConstraint' : \\
\t1 Substrate \fun refinedExpressionConstraint' \fun Sctids\_or\_Error
\end{axdef}

\subsubsection{simpleExpressionConstraint}
\begin{framed}
\desc{A simple expression constraint includes exactly one focus concept, optionally preceded by a constraint operator.}
\end{framed}
\begin{framed}
\noindent
\bnf{simpleExpressionConstraint =  [constraintOperator ws] focusConcept} 
\end{framed}

The interpretation of  \spec{simpleExpressionConstraint} is the application of an optional constraint 
operator to the interpretation of \spec{focusConcept}, which returns a set of sctId's or an error.
The interpretation of an error is the error.

\begin{zed}
simpleExpressionConstraint == \optional[constraintOperator] \cross focusConcept \\
\end{zed} 

\begin{axdef}
   i\_simpleExpressionConstraint : \\
\t2 Substrate \fun simpleExpressionConstraint \fun Sctids\_or\_Error
\where
   \forall ss : Substrate; sec : simpleExpressionConstraint @ \\
i\_simpleExpressionConstraint~ss~sec =  \\
\t2 i\_constraintOperator~ss~(first~sec)~(i\_focusConcept~ss~(second~sec))
\end{axdef}


\subsubsection{compoundExpressionConstraint}
\begin{framed}
\desc{A compound expression constraint contains two or more simple expression constraints joined by either a conjunction, disjunction or exclusion. Compound expression constraints may optionally be placed in brackets.}
\end{framed}

\begin{framed}
\noindent
\bnf{	compoundExpressionConstraint = conjunctionExpressionConstraint / 
                               disjunctionExpressionConstraint / 
                               exclusionExpressionConstraint / 			
                               ``('' ws compoundExpressionConstraint ws ``)''}
\end{framed}

The interpretation of a $compoundExpressionConstraint$ is the interpretation the conjunction, disjunction or exclusion of nested compound constraint.

\begin{zed}
compoundExpressionConstraint ::= \\
\t2 compound\_conj \ldata conjunctionExpressionConstraint \rdata | \\
\t2 compound\_disj \ldata disjunctionExpressionConstraint \rdata | \\
\t2 compound\_excl \ldata exclusionExpressionConstraint \rdata | \\
\t2 compound\_nested \ldata compoundExpressionConstraint \rdata \\
[compoundExpressionConstraint']
\end{zed}

\begin{axdef}
   i\_compoundExpressionConstraint : \\
\t2 Substrate \fun compoundExpressionConstraint \fun Sctids\_or\_Error \\
\where
  \forall ss : Substrate; cec : compoundExpressionConstraint @ \\
 i\_compoundExpressionConstraint~ss~cec = \\
   \IF cec \in \ran compound\_conj \THEN  \\
\t1 i\_conjunctionExpressionConstraint~ss~(compound\_conj \inv cec) \\
    \ELSE \IF cec \in \ran compound\_disj \THEN \\
\t1 i\_disjunctionExpressionConstraint~ss~(compound\_disj \inv cec) \\
    \ELSE \IF cec \in \ran compound\_excl \THEN \\
\t1 i\_exclusionExpressionConstraint~ss~(compound\_excl \inv cec) \\
   \ELSE \\
\t1 i\_compoundExpressionConstraint~ss~(compound\_nested \inv cec)
\end{axdef}
\begin{axdef}
   i\_compoundExpressionConstraint ': \\
\t2 Substrate \fun compoundExpressionConstraint' \fun Sctids\_or\_Error
\end{axdef}



\subsubsection{conjunctionExpressionConstraint}
\begin{framed}
\desc{A conjunction expression constraint combines two or more expression constraints with a conjunction (``and'') operator. More than one conjunction may be used without brackets. However any compound expression constraint (using a different binary operator) that appears within a conjunction expression constraint must be enclosed by brackets.}
\end{framed}

\begin{framed}
\noindent
\bnf{conjunctionExpressionConstraint = subExpressionConstraint 1*(ws conjunction ws subExpressionConstraint)}
\end{framed}

\spec{conjunctionExpressionConstraint} is interpreted as the \underline{intersection} of the interpretations of the
\spec{subExpressionConstraints}.

\begin{zed}
conjunctionExpressionConstraint == \\
\t2 subExpressionConstraint \cross \seq_1(subExpressionConstraint)
\end{zed}

Apply the intersection operator to the interpretation of each  subExpressionConstraint

\begin{axdef}
    i\_conjunctionExpressionConstraint : \\
\t1 Substrate \fun conjunctionExpressionConstraint \fun Sctids\_or\_Error
\where
   \forall ss : Substrate;  cecr : conjunctionExpressionConstraint @ \\
i\_conjunctionExpressionConstraint~ss~cecr = \\
\t1 applyToSequence~ss~i\_subExpressionConstraint~intersect~cecr
\end{axdef}

\subsubsection{disjunctionExpressionConstraint}
\begin{framed}
\desc{A disjunction expression constraint combines two or more expression constraints with a disjunction (``or'') operator. More than one disjunction may be used without brackets. However any compound expression constraint (using a different binary operator) that appears within a disjunction expression constraint must be enclosed by brackets.}
\end{framed}

\begin{framed}
\noindent
\bnf{disjunctionExpressionConstraint = subExpressionConstraint 1*(ws disjunction ws subExpressionConstraint)}
\end{framed}

\begin{zed}
disjunctionExpressionConstraint == \\
\t2 subExpressionConstraint \cross \seq_1(subExpressionConstraint)
\end{zed}

\spec{disjunctionExpressionConstraint} is interpreted as the \underline{union} of the interpretations of the
\spec{subExpressionConstraints}.

\begin{axdef}
    i\_disjunctionExpressionConstraint : \\
\t1 Substrate \fun disjunctionExpressionConstraint \fun Sctids\_or\_Error
\where
   \forall ss : Substrate;  decr : disjunctionExpressionConstraint @ \\
i\_disjunctionExpressionConstraint~ss~decr = \\
\t1 applyToSequence~ss~i\_subExpressionConstraint~union~decr
\end{axdef}




\subsubsection{exclusionExpressionConstraint}
\begin{framed}
\desc{An exclusion expression constraint combines two expression constrains with an exclusion (``minus'') operator. A single exclusion operator may be used without brackets. However when the operands of the exclusion expression constraint are compound, these compound expression constraints must be enclosed by brackets.}
\end{framed}

\begin{framed}
\noindent
\bnf{exclusionExpressionConstraint = subExpressionConstraint ws exclusion ws subExpressionConstraint}
\end{framed}

\spec{exclusionEspressionConstraint} is interpreted as the  interpretation of the
\spec{subExpressionConstraint} \underline{minus} the interpretation of the second.

\begin{zed}
exclusionExpressionConstraint == \\ 
\t2subExpressionConstraint \cross subExpressionConstraint
\end{zed}

\begin{axdef}
    i\_exclusionExpressionConstraint : \\
\t2 Substrate \fun exclusionExpressionConstraint \fun Sctids\_or\_Error
\where
   \forall ss : Substrate; ecr : exclusionExpressionConstraint @ \\
   (\LET first\_sec == (i\_subExpressionConstraint~ss~(first~ecr)); \\
   \t1 second\_sec == (i\_subExpressionConstraint~ss~(second~ecr)) @ \\
i\_exclusionExpressionConstraint~ss~ecr =  minus~~first\_sec~second\_sec)
\end{axdef}

\subsubsection{subExpressionConstraint}
\begin{framed}
\desc{A subexpression constraint, which appears within a compound expression constraint, must either be simple, or a bracketed compound or refined expression constraint.}
\end{framed}

\begin{framed}
\noindent
\bnf{subExpressionConstraint = simpleExpressionConstraint / ``('' ws (compoundExpressionConstraint / refinedExpressionConstraint)  ws ``)''}
\end{framed}

The interpretation of \spec{subExpressionConstraint} is  the interpretation the \spec{simpleExpressionConstraint} \spec{compoundExpressionConstraint} or \spec{refinedExpressionConstraint}

\begin{zed}
subExpressionConstraint ::= \\
\t1 subExpr\_simple \ldata simpleExpressionConstraint \rdata | \\
\t1 subExpr\_compound \ldata compoundExpressionConstraint' \rdata | \\
\t1 subExpr\_refined \ldata refinedExpressionConstraint' \rdata
\end{zed}

\begin{axdef}
   i\_subExpressionConstraint : \\
\t2 Substrate \fun subExpressionConstraint \fun Sctids\_or\_Error
\where
   \forall ss : Substrate; sec : subExpressionConstraint @ \\
i\_subExpressionConstraint~ss~sec = \\
   \IF sec \in \ran subExpr\_simple \THEN \\
   \t1 i\_simpleExpressionConstraint~ss~(subExpr\_simple \inv sec) \\
    \ELSE \IF sec \in \ran subExpr\_compound \THEN \\
    \t1 i\_compoundExpressionConstraint'~ss~(subExpr\_compound \inv sec) \\
    \ELSE \\
    \t1 i\_refinedExpressionConstraint'~ss~(subExpr\_refined \inv sec) 
\end{axdef}

\subsection{refinement}
\begin{framed}
\desc{A refinement contains all the grouped and ungrouped attributes that refine the set of clinical meanings satisfied by the expression constraint. Refinements may represent the conjunction or disjunction of two smaller refinements, and may optionally be placed in brackets. Where both conjunction and disjunction are used, brackets are mandatory to disambiguate the intended meaning.}
\end{framed}
\begin{framed}
\noindent
\bnf{refinement = subRefinement ws [conjunctionRefinementSet / disjunctionRefinementSet]}
\end{framed}

The interpretation of \spec{refinement} is one of:
\begin{itemize}[noitemsep,nolistsep]
\item The \underline{intersection} of the interpretation of the \spec{subRefinement} and the \spec{conjunctionRefinementSet}
\item The \underline{union} of the interpretation of the \spec{subRefinement} and the \spec{disjunctionRefinementSet}
\item The interpretation of  \spec{subRefinement} if neither conjunction nor disjunction set is present
\end{itemize}

\begin{zed}
refinement == subRefinement \cross \optional[refinementConjunctionOrDisjunction] \\
[refinement']
\also
refinementConjunctionOrDisjunction ::= \\
\t1 refine\_conjset \ldata conjunctionRefinementSet \rdata | \\
\t1 refine\_disjset \ldata disjunctionRefinementSet \rdata
\end{zed}




\begin{axdef}
   i\_refinement : Substrate \fun refinement \fun Sctids\_or\_Error
\where
   \forall ss : Substrate; rfnment : refinement @ \\
    i\_refinement~ss~rfnment = \\
   (\LET lhs == i\_subRefinement~ss~(first~rfnment); rhs == second~rfnment @ \\
   \IF \# rhs = 0 \THEN \\
   \t1 lhs \\
    \ELSE \IF (head~rhs) \in \ran refine\_conjset \THEN  \\
    \t1 intersect~lhs~(i\_conjunctionRefinementSet~ss~(refine\_conjset \inv (head~rhs))) \\
  \ELSE \\
  \t1 union~lhs~(i\_disjunctionRefinementSet~ss~(refine\_disjset \inv (head~rhs))))
\end{axdef}
\begin{axdef}
   i\_refinement' : Substrate \fun refinement' \fun Sctids\_or\_Error
\end{axdef}

\subsubsection{conjunctionRefinementSet}
\begin{framed}
\desc{A conjunction refinement set consists of one or more conjunction operators, each followed by a subRefinement.}
\end{framed}
\begin{framed}
\noindent
\bnf{conjunctionRefinementSet = 1*(ws conjunction ws subRefinement)}
\end{framed}

\begin{zed}
conjunctionRefinementSet == \seq_1 subRefinement 
\end{zed}

The interpretation of a \spec{conjunctionRefinementSet} is the \underline{intersection} of the interpretation of the \spec{subrefinements}.

\begin{axdef}
    i\_conjunctionRefinementSet : \\
\t1 Substrate \fun conjunctionRefinementSet \fun Sctids\_or\_Error
\where
   \forall ss : Substrate;  conjset : conjunctionRefinementSet @ \\
   i\_conjunctionRefinementSet~ss~conjset = ~ \\
   \IF tail~conjset = \langle \rangle \THEN \\
   \t1 i\_subRefinement~ss~(head~conjset) \\
\ELSE \\
\t1 intersect~(i\_subRefinement~ss~(head~conjset))~(i\_conjunctionRefinementSet~ss~(tail~conjset))
\end{axdef}

\subsubsection{disjunctionRefinementSet}
\begin{framed}
\noindent
\bnf{disjunctionRefinementSet = 1*(ws disjunction ws subRefinement)}
\end{framed}

\begin{zed}
disjunctionRefinementSet == \seq_1 subRefinement 
\end{zed}

The interpretation of a \spec{disjunctionRefinementSet} is the \underline{union} of the interpretation of the \spec{subrefinements}.

\begin{axdef}
    i\_disjunctionRefinementSet : \\
\t1 Substrate \fun disjunctionRefinementSet \fun Sctids\_or\_Error
\where
   \forall ss : Substrate;  disjset : disjunctionRefinementSet @ \\
   i\_disjunctionRefinementSet~ss~disjset = ~ \\
   \IF tail~disjset =  \langle \rangle \THEN \\
   \t1 i\_subRefinement~ss~(head~disjset) \\
\ELSE \\
\t1 union~(i\_subRefinement~ss~(head~disjset))~(i\_disjunctionRefinementSet~ss~(tail~disjset))
\end{axdef}


\subsubsection{subRefinement}
\begin{framed}
\desc{ A subRefinement is either an attribute set, an attribute group or a bracketed refinement.}
\end{framed}

\begin{framed}
\noindent
\bnf{subRefinement = attributeSet / attributeGroup / ``('' ws refinement ws ``)''}
\end{framed}

The interpretation of a \spec{subRefinement} is the interpretation of the corresponding \spec{attributeSet}, \spec{attributeGroup} or \spec{refinement}.

\begin{zed}
subRefinement ::= \\
\t1 subrefine\_attset \ldata attributeSet \rdata | \\
\t1 subrefine\_attgroup \ldata attributeGroup \rdata | \\
\t1 subrefine\_refinement \ldata refinement' \rdata
\end{zed}


\begin{axdef}
   i\_subRefinement : \\
\t2 Substrate \fun subRefinement \fun Sctids\_or\_Error
\where
   \forall ss : Substrate; subrefine : subRefinement @ \\
   i\_subRefinement~ss~subrefine = \\
   \IF subrefine \in \ran subrefine\_attset \THEN\\
   \t1  i\_attributeSet~ss~(subrefine\_attset \inv subrefine) \\
   \ELSE \IF subrefine \in \ran subrefine\_attgroup \THEN \\
   \t1 i\_attributeGroup~ss~(subrefine\_attgroup \inv subrefine) \\
  \ELSE \\
  \t1 i\_refinement'~ss~(subrefine\_refinement \inv subrefine)
\end{axdef}

\subsection{attributeSet}
\begin{framed}
\desc{An attribute set contains one or more attribute name-value pairs separated by a conjunction or disjunction operator. An attribute set may optionally be placed in brackets.}
\end{framed}

\begin{framed}
\noindent
\bnf{attributeSet = subAttributeSet ws [conjunctionAttributeSet / disjunctionAttributeSet]}
\end{framed}

The interpretation of an \spec{attributeSet} is one of:
\begin{itemize}[noitemsep,nolistsep]
\item The \underline{intersection} of the interpretation of the \spec{subAttributeSet} and the \spec{conjunctionAttributeSet}
\item The \underline{union} of the interpretation of the \spec{subAttributeSet} and the \spec{disjunctionAttributeSet}
\item The interpretation of  \spec{subAttributeSet} if neither conjunction nor disjunction set is present
\end{itemize}


\begin{zed}
attributeSet == subAttributeSet \cross \optional[conjunctionOrDisjunctionAttributeSet] \\
[attributeSet']
\also
conjunctionOrDisjunctionAttributeSet ::= \\
\t1 attset\_conjattset \ldata conjunctionAttributeSet \rdata | \\
\t1 attset\_disjattset \ldata disjunctionAttributeSet \rdata
\end{zed}

\begin{axdef}
   i\_attributeSet : \\
\t1 Substrate \fun attributeSet \fun Sctids\_or\_Error
\where
   \forall ss : Substrate; attset : attributeSet @ \\
   i\_attributeSet~ss~attset = \\
   (\LET lhs == i\_subAttributeSet~ss~(first~attset); rhs == second~attset @ \\
 \IF \# rhs = 0 \THEN \\
 \t1 lhs \\
 \ELSE \IF head~rhs \in \ran attset\_conjattset \THEN \\
 \t1  intersect~lhs~(i\_conjunctionAttributeSet~ss~(attset\_conjattset \inv (head~rhs))) \\
  \ELSE \\
  \t1 union~lhs~(i\_disjunctionAttributeSet~ss~(attset\_disjattset \inv (head~rhs))))
\end{axdef}

\begin{axdef}
   i\_attributeSet' : \\
\t1 Substrate \fun attributeSet' \fun Sctids\_or\_Error
\end{axdef}

\subsubsection{conjunctionAttributeSet}
\begin{framed}
\desc{A conjunction attribute set consists of one or more conjunction operators, each followed by a subAttributeSet.}
\end{framed}
\begin{framed}
\noindent
\bnf{conjunctionAttributeSet = 1*(ws conjunction ws subAttributeSet)}
\end{framed}

The interpretation of a \spec{conjunctionAttributeSet } is the \underline{intersection} of the interpretations of its \spec{subAttributeSets}.


\begin{zed}
conjunctionAttributeSet ==  \seq_1 subAttributeSet 
\end{zed}

\begin{axdef}
    i\_conjunctionAttributeSet : \\
\t1 Substrate \fun conjunctionAttributeSet \fun Sctids\_or\_Error
\where
   \forall ss : Substrate;  conjset : conjunctionAttributeSet @ \\
   i\_conjunctionAttributeSet~ss~conjset = ~ \\
   \IF tail~conjset = \langle \rangle  \THEN \\
   \t1 i\_subAttributeSet~ss~(head~conjset) \\
\ELSE \\
\t1 intersect~(i\_subAttributeSet~ss~(head~conjset))~(i\_conjunctionAttributeSet~ss~(tail~conjset))
\end{axdef}


\subsubsection{disjunctionAttributeSet}
\begin{framed}
\desc{A disjunction attribute set consists of one or more disjunction operators, each followed by a subAttributeSet.}
\end{framed}
\begin{framed}
\noindent
\bnf{disjunctionAttributeSet = 1*(ws disjunction ws subAttributeSet)}
\end{framed}

The interpretation of a \spec{disjunctionAttributeSet } is the \underline{union} of the interpretations of its \spec{subAttributeSets}.


\begin{zed}
disjunctionAttributeSet ==  \seq_1 subAttributeSet 
\end{zed}

\begin{axdef}
    i\_disjunctionAttributeSet : \\
\t1 Substrate \fun disjunctionAttributeSet \fun Sctids\_or\_Error
\where
   \forall ss : Substrate;  disjset : disjunctionAttributeSet @ \\
   i\_disjunctionAttributeSet~ss~disjset = ~ \\
   \IF tail~disjset = \langle \rangle \THEN \\
   \t1 i\_subAttributeSet~ss~(head~disjset) \\
\ELSE \\
\t1 union~(i\_subAttributeSet~ss~(head~disjset))~(i\_disjunctionAttributeSet~ss~(tail~disjset))
\end{axdef}

\subsubsection{subAttributeSet}
\begin{framed}
\desc{A subAttributeSet is either an attribute or a bracketed attribute set.}
\end{framed}
\begin{framed}
\noindent
\bnf{subAttributeSet = attribute / ``('' ws attributeSet ws ``)''}
\end{framed}

The interpretation of a \spec{subAttributeSet} is either the interpretation of the \spec{attribute} or the interpretation of the \spec{attributeSet}.

\begin{zed}
subAttributeSet ::= \\
\t1 subaset\_attribute \ldata attribute \rdata | \\
\t1 subaset\_attset \ldata attributeSet' \rdata
\end{zed}

\begin{axdef}
   i\_subAttributeSet : \\
\t2 Substrate \fun subAttributeSet \fun Sctids\_or\_Error
\where
   \forall ss : Substrate; subaset : subAttributeSet @ \\
   i\_subAttributeSet~ss~subaset = \\
   \IF subaset \in \ran subaset\_attribute \THEN \\
   \t1 i\_attribute~ss~(subaset\_attribute \inv subaset) \\
  \ELSE \\
  \t1 i\_attributeSet'~ss~(subaset\_attset \inv subaset)
\end{axdef}

\subsection{attribute}
\begin{framed}
\desc{An attribute is a name-value pair expressing a single refinement of the containing expression constraint. Either the attribute value must satisfy (or not) the given expression constraint, the attribute value is compared with a given numeric value (integer or decimal) using a numeric comparison operator, or the attribute value must be equal to (or not equal to) the given string value. The attribute may optionally be preceded by a cardinality constraint, a reverse flag and/or an attribute operator.}
\end{framed}

\begin{framed}
\noindent
\bnf{attribute = [cardinality ws] [reverseFlag ws] [attributeOperator ws] attributeName ws 		
			(expressionComparisonOperator ws expressionConstraintValue /
			 numericComparisonOperator ws numericValue / 		
			 stringComparisonOperator ws stringValue}
\bnf{numericValue =  ``\#'' ( decimalValue / integerValue)}
\end{framed}

Conceptually, the interpretation of \spec{attribute} consists of the following steps:
\begin{enumerate}[noitemsep]
\item Interpret \spec{attributeName}
\item Interpret \spec{attributeOperator} against the result of the previous step
\item Interpret one of:
\begin{itemize}[noitemsep]
\item The \spec{expressionComparisonOperator} applied to the \spec{reverseFlag}, the interpretation of \spec{attributeOperator} and  \spec{expressionConstraintValue}.
\item The \spec{numericComparisonOperator} applied to the interpretation of \spec{attributeOperator} and  \spec{numericValue}.
\item The \spec{stringComparisonOperator} applied to the interpretation of \spec{attributeOperator} and \spec{stringValue}.
\end{itemize} 
\item Interpret \spec{cardinality} against the result of the previous step
\end{enumerate}

Note that the \spec{reverseFlag} only applies in the case of \spec{expressionComparisonOperator}.  Not sure what to do if it is present in the other two cases...

The schema below provides names the various components of an attribute.
\begin{schema}{attribute}
   card : \optional[cardinality] \\
   rf : \optional[reverseFlag] \\
   attOper : \optional[constraintOperator] \\
   name : attributeName \\
   opValue : attributeOperatorValue
\end{schema}

\begin{zed}
attributeOperatorValue ::= \\
\t1 attrib\_expr \ldata expressionComparisonOperator \cross expressionConstraintValue \rdata |
\also
\t1 attrib\_num \ldata numericComparisonOperator \cross numericValue \rdata | 
\also
\t1 attrib\_str \ldata stringComparisonOperator \cross stringValue \rdata \\
\also
numericValue ::= nv\_decimal \ldata decimalValue \rdata |  nv\_integer \ldata \nat \rdata 
\also
[reverseFlag] 
\end{zed}

\begin{axdef}
   i\_attribute : \\
\t1 Substrate  \fun attribute \fun Sctids\_or\_Error
\where
   \forall ss : Substrate; att : attribute @ \\
   i\_attribute~ss~att = \\
   (\LET att\_sctids == i\_attributeOperator~ss~att.attOper~(ss.i\_attributeName~att.name) @ \\
   \IF att\_sctids \in \ran error \THEN \\
   \t1 att\_sctids
\also
   \ELSE \IF att.opValue \in \ran attrib\_expr \THEN \\
\t1 (\LET expr\_interp == \\
\t1 i\_expressionComparisonOperator~ss~att.rf~(result\_sctids~att\_sctids)~(attrib\_expr \inv att.opValue)  @ \\
\t2 i\_att\_cardinality~ss~att.card~expr\_interp)
\also
   \ELSE \IF att.opValue \in \ran attrib\_num \\
\t1 \THEN \\
\t1 (\LET num\_interp == \\
\t1 i\_numericComparisonOperator~ss~att.rf~(result\_sctids~att\_sctids)~(attrib\_num \inv att.opValue)  @ \\
\t2 i\_att\_cardinality~ss~att.card~num\_interp)
\also
   \ELSE  \\
\t1 (\LET str\_interp == \\
\t1 i\_stringComparisonOperator~ss~att.rf~(result\_sctids~att\_sctids)~(attrib\_str \inv att.opValue)  @ \\
\t2 i\_att\_cardinality~ss~att.card~str\_interp))
\end{axdef}

\subsubsection{attribute cardinality}
\begin{framed}
\desc{The cardinality of an attribute represents a constraint on the minimum and maximum number of instances of the given attribute on each concept. The cardinality is enclosed in square brackets with the minimum cardinality appearing first, followed by two dots and then the maximum cardinality. The minimum cardinality must always be less than or equal to the maximum cardinality. A maximum cardinality of 'many' indicates that there is no limit on the number of times the attribute may appear on each concept.}
\end{framed}
\begin{framed}
\bnf{cardinality = ``['' nonNegativeIntegerValue to (nonNegativeIntegerValue / many) ``]''}
\end{framed}

\begin{zed}
unlimitedNat ::= num \ldata \nat \rdata | many \\
\end{zed}
\begin{schema}{cardinality}
   min : \nat;
   max : unlimitedNat \\
\end{schema}
   
   
The interpretation of $optional[cardinality]$ in the context of an attribute is:
\begin{enumerate}[noitemsep]
\item $error$ if there is an error in the supplied list of quads 
\item $i\_required\_cardinality~1~many$ if the cardinality isn't supplied 
\item $i\_required\_cardinality~cardinality$ if the minimum cardinality is $>$ 0
\item $i\_optionali\_cardinality~ss~cardinality$ if the minimum cardinality = 0
\end{enumerate}


\begin{axdef}
   i\_att\_cardinality : \\
\t1 Substrate \fun \optional[cardinality] \fun Quads\_or\_Error \fun Sctids\_or\_Error
\where
   \forall ss:Substrate; ocard : \optional[cardinality]; qore : Quads\_or\_Error @ \\
   i\_att\_cardinality~ss~ocard~qore = \\
\IF qore \in \ran qerror \THEN \\
\t1 error (qerror \inv qore) \\
\ELSE \IF \# ocard = 0 \THEN \\
\t1 ok~(i\_required\_cardinality~1~many~qore) \\
\ELSE (\LET card == head~ocard @ \\
\t1 \IF card.min > 0 \THEN \\
\t2 ok~(i\_required\_cardinality~card.min~card.max~qore) \\
\t1 \ELSE \\
\t2 ok~(i\_optional\_cardinality~ss~card.max~qore))
\end{axdef}

$i\_required\_cardinality$ returns the set of subject or target sctids that meet the cardinality requirements
\begin{axdef}
   i\_required\_cardinality : \\
\t1 \nat \fun unlimitedNat \fun Quads\_or\_Error \ \fun \power sctId
\where
   \forall min : \nat; max : unlimitedNat; qore : Quads\_or\_Error  @ \\
i\_required\_cardinality~min~max~qore = \\
\IF quad\_direction~qore = source\_direction \THEN \\
\t1 \{subj :  \{q : quads\_for~qore @ q.s \} | \\
\t1 evalCardinality[Quad]~min~max~\{q : quads\_for~qore | q.s = subj\} \neq \emptyset \} \\
\ELSE \\
\t1 \{targ :  \{q : quads\_for~qore @ t\_sctid \inv q.t \} | \\
\t1 evalCardinality[Quad]~min~max~\{q : quads\_for~qore | (t\_sctid \inv q.t) = targ\} \neq \emptyset \}
\end{axdef}

$i\_optional\_cardinality$ returns all of the concepts in the substrate that don't \emph{fail} the cardinality test.  The failing concepts
are equivalent to the set of all subject (or target) concepts in the set of quads minus the set of concepts that pass.

\begin{axdef}
   i\_optional\_cardinality : \\
\t1 Substrate \fun unlimitedNat \fun Quads\_or\_Error \ \fun \power sctId
\where
   \forall ss:Substrate; max : unlimitedNat; qore : Quads\_or\_Error  @ \\
i\_optional\_cardinality~ss~max~qore = \\
\IF quad\_direction~qore = source\_direction \THEN \\
\t1 ss.concepts \setminus (\{q : quads\_for~qore @ q.s \} \setminus (i\_required\_cardinality~0~max~qore)) \\
\ELSE \\
\t1 ss.concepts \setminus (\{q : quads\_for~qore @ t\_sctid \inv q.t \} \setminus (i\_required\_cardinality~0~max~qore)) 
\end{axdef}



\subsubsection{expressionConstraintValue}
\begin{framed}
\desc{An expression constraint value is either a simple expression constraint, or is a refined or compound expression constraint enclosed in brackets.}
\end{framed}

\begin{framed}
\noindent
\bnf{expressionConstraintValue = simpleExpressionConstraint / ``('' ws (refinedExpressionConstraint / compoundExpressionConstraint) ws ``)''}
\end{framed}

The interpretation of \spec{expressionConstraintValue} is the interpretation of the corresponding \spec{simpleExpressionConstraint}, \spec{refinedExpressionConstraint} or
\spec{compoundExpressionConstraint}

\begin{zed}
expressionConstraintValue ::= \\
\t1 expression\_simple \ldata simpleExpressionConstraint \rdata | \\
\t1 expression\_refined \ldata refinedExpressionConstraint' \rdata | \\
\t1 expression\_compound \ldata compoundExpressionConstraint \rdata
\end{zed}

\begin{axdef}
   i\_expressionConstraintValue : \\
\t1 Substrate \fun expressionConstraintValue \fun Sctids\_or\_Error
\where
   \forall ss : Substrate; ecv : expressionConstraintValue @ \\
   i\_expressionConstraintValue~ss~ecv = \\
\IF ecv \in \ran expression\_simple  \THEN \\
\t1 i\_simpleExpressionConstraint~ss~(expression\_simple \inv ecv) \\
\ELSE \IF ecv \in \ran expression\_refined \THEN \\
\t1 i\_refinedExpressionConstraint'~ss~(expression\_refined \inv ecv) \\
\ELSE \\
\t1 i\_compoundExpressionConstraint~ss~(expression\_compound \inv ecv)
\end{axdef}



\subsection{attributeGroup}
\begin{framed}
\desc{An attribute group contains a collection of attributes that operate together as part of the refinement of the containing expression constraint. An attribute group may optionally be preceded by a cardinality. An attribute group cardinality indicates the minimum and maximum number of attribute groups that must satisfy the given attributeSet constraint for the expression constraint to be satisfied.}
\end{framed}
\begin{framed}
\noindent
\bnf{attributeGroup = [cardinality ws] ``\{'' ws attributeSet ws ``\}''}
\end{framed}

\begin{zed}
attributeGroup == \optional[cardinality] \cross attributeSet
\end{zed}

The difference between the interpretation of an \spec{attributeGroup} and an \spec{attributeSet} is that, within an \spec{attributeGroup} all of the 
qualifying \spec{sctIds} must belong to the same group \footnote{The zero group is a special case, where each quad in a zero group is viewed as its own unique group}.  Outside, a \spec{sctId} would qualify an conjunction if one group passed the first match
and a different one the second.  \emph{Within} a group, however, conjunctions and disjunctions only count if they both apply in the same group.  This means
that we have to re-interpret the meaning of \spec{attributeSet} on down in terms of $IDGroup$s rather than $Quads$

The interpretation of an attribute group is the application of a cardinality constraint to all of the $sctId$s that pass the grouped 
attribute set.

\begin{axdef}
   i\_attributeGroup : Substrate \fun attributeGroup \fun Sctids\_or\_Error
\where
   \forall ss : Substrate; ag : attributeGroup @ \\
   i\_attributeGroup~ss~ag = \\
   \t1  i\_group\_cardinality~ss~(first~ag)~(i\_groupAttributeSet~ss~(second~ag))
\end{axdef}

\subsubsection{attribute group cardinality}
The interpretation of \spec{cardinality} within the context of an attribute group is as follows:
\begin{itemize}[noitemsep]
\item If an error has been encountered anywhere in the process, it should be propagated.
\item If the cardinality is omitted, it is interpreted as [1 .. *]
\item If the minimum cardinality is \textgreater  0 then return the set of sctids with that appear at least $min$ and at most $max$ groups
\item If the minimum cardinality is 0 then return every sctid that doesn't fail the max cardinality
\end{itemize}

\begin{axdef}
   i\_group\_cardinality: \\
\t1 Substrate \fun \optional[cardinality] \fun sctIdGroups\_or\_Error \fun Sctids\_or\_Error
\where
   \forall ss: Substrate; ocard : \optional[cardinality]; idg : sctIdGroups\_or\_Error @ \\
   i\_group\_cardinality~ss~ocard~idg = \\
   \IF idg \in \ran gerror \THEN \\
   \t1 error(gerror \inv idg)
\also
\ELSE (\LET gvals == group\_value \inv idg @ \\
\t1 \IF \# ocard = 0 \THEN \\
\t2 ok (i\_required\_group\_cardinality~1~many~gvals)
\also
\t1 \ELSE (\LET card == head~ocard @ \\
\t2  \IF card.min > 0 \THEN \\
\t3  ok (i\_required\_group\_cardinality~card.min~card.max~gvals)
\also
\t2 \ELSE \\
\t3 ok (i\_optional\_group\_cardinality~ss~card.max~gvals )))
\end{axdef}


$i\_required\_group\_cardinality$ returns the set  $sctids$ that pass in at least $min$ groups and at most $max$ groups
\begin{axdef}
   i\_required\_group\_cardinality : \\
\t1 \nat \fun unlimitedNat \fun \power sctIdGroup \fun \power sctId
\where
   \forall min : \nat; max : unlimitedNat; groups : \power sctIdGroup  @ \\
i\_required\_group\_cardinality~min~max~groups = \\
\{sctid :  \{ s : groups @ first~s \} | \\
\t1 evalCardinality[sctIdGroup]~min~max \{g : groups | first~g = sctid \} \neq \emptyset \}
\end{axdef}

$i\_optional\_group\_cardinality$ returns the set of $sctids$ that pass in at most $max$ groups, which is equivalent to the
set of all possible $sctIds$ (i.e. $ss.concepts$) minus the set of $sctids$ that pass in more than $max$ groups.

\begin{axdef}
   i\_optional\_group\_cardinality : \\
\t1 Substrate \fun unlimitedNat \fun \power sctIdGroup  \fun \power sctId
\where
   \forall ss:Substrate; max : unlimitedNat; groups: \power sctIdGroup  @ \\
i\_optional\_group\_cardinality~ss~max~groups = \\
ss.concepts \setminus \\
\t1 (\{ s : groups @ first~s \} \setminus (i\_required\_group\_cardinality~0~max~groups)) 
\end{axdef}



\subsubsection{attributeSet inside a group}
The interpretation of an \spec{attributeSet} a group is the interpretation of the \spec{subAttributeSet}
optionally intersected or union with additional conjunction or disjunction attribute sets.


\begin{axdef}
   i\_groupAttributeSet : \\
\t1 Substrate \fun attributeSet \fun sctIdGroups\_or\_Error
\where
   \forall ss : Substrate; attset : attributeSet @ \\
   i\_groupAttributeSet~ss~attset = \\
   (\LET lhs == i\_groupSubAttributeSet~ss~(first~attset); rhs == second~attset @ \\
 \IF \# rhs = 0 \THEN \\
 \t1 lhs \\
 \ELSE \IF head~rhs \in \ran attset\_conjattset \THEN \\
 \t1 gintersect~lhs~(i\_groupConjunctionAttributeSet~ss~(attset\_conjattset \inv (head~rhs))) \\
  \ELSE \\
  \t1 gunion~lhs~(i\_groupDisjunctionAttributeSet~ss~(attset\_disjattset \inv (head~rhs))))
\end{axdef}
\begin{axdef}
   i\_groupAttributeSet' : \\
\t1 Substrate \fun attributeSet' \fun sctIdGroups\_or\_Error
\end{axdef}

\subsubsection{conjunctionAttributeSet inside a group}
Apply the intersect operator to the interpretation of each  subAttributeSet in a group context. This is the same as the non-grouped $subAttributeSet$ with the exception that the inputs to and result of the function is $sctId$ / $groupId$ tuples rather than



\begin{axdef}
    i\_groupConjunctionAttributeSet : \\
\t1 Substrate \fun conjunctionAttributeSet \fun sctIdGroups\_or\_Error
\where
   \forall ss : Substrate;  conjset : conjunctionAttributeSet @ \\
   i\_groupConjunctionAttributeSet~ss~conjset = ~ \\
   \IF tail~conjset = \langle \rangle \THEN \\
   \t1 i\_groupSubAttributeSet~ss~(head~conjset) \\
\ELSE \\
\t1 gintersect~(i\_groupSubAttributeSet~ss~(head~conjset))~(i\_groupConjunctionAttributeSet~ss~(tail~conjset))
\end{axdef}


\subsubsection{disjunctionAttributeSet inside a group}
Apply the union operator to the interpretation of each  subAttributeSet in a group context.  This is the same as the non-grouped $subAttributeSet$ with the exception that the inputs to and result of the function is $sctId$ / $groupId$ tuples rather than
just $sctIds$.


\begin{axdef}
    i\_groupDisjunctionAttributeSet : \\
\t1 Substrate \fun disjunctionAttributeSet \fun sctIdGroups\_or\_Error
\where
   \forall ss : Substrate;  disjset : disjunctionAttributeSet @ \\
   i\_groupConjunctionAttributeSet~ss~disjset = ~ \\
   \IF tail~disjset = \langle \rangle \THEN \\
   \t1  i\_groupSubAttributeSet~ss~(head~disjset) \\
\ELSE \\
\t1 gunion~(i\_groupSubAttributeSet~ss~(head~disjset))~(i\_groupConjunctionAttributeSet~ss~(tail~disjset))
\end{axdef}

\subsubsection{subAttributeSet inside a group}
This is the same as the non-grouped $subAttributeSet$ with the exception that the result of the function is $sctId$ / $groupId$ tuples rather than
just $sctIds$.


\begin{axdef}
   i\_groupSubAttributeSet : \\
\t2 Substrate \fun subAttributeSet \fun sctIdGroups\_or\_Error 
\where
   \forall ss : Substrate; subaset : subAttributeSet @ \\
   i\_groupSubAttributeSet~ss~subaset = \\
   \IF subaset \in \ran subaset\_attribute \\
\t1 \THEN i\_groupAttribute~ss~(subaset\_attribute \inv subaset) \\
  \ELSE i\_groupAttributeSet'~ss~(subaset\_attset \inv subaset)
\end{axdef}



\subsubsection{attribute inside a group}
The interpretation of an attribute within the context of a group is the set of $sctIds$ and the group or groups in which
they were valid.  It is possible for the same $sctId$ to valid in the interpretation of a given attribute for more than one group.
The union and intersection operators operate on the $sctId$ / $groupId$ tuples (ne. $sctIdGroup$).


\begin{axdef}
   i\_groupAttribute : \\
\t1 Substrate  \fun attribute \fun sctIdGroups\_or\_Error 
\where
   \forall ss : Substrate; att : attribute @ \\
   i\_groupAttribute~ss~att = \\
   (\LET att\_sctids == i\_attributeOperator~ss~att.attOper~(ss.i\_attributeName~att.name) @ \\
   \IF att\_sctids \in \ran error \\
\t1 \THEN gerror(error \inv att\_sctids)
\also
   \ELSE \IF att.opValue \in \ran attrib\_expr \THEN \\
\t1 (\LET expr\_interp == \\
\t1 i\_expressionComparisonOperator~ss~att.rf~(result\_sctids~att\_sctids)~(attrib\_expr \inv att.opValue)  @ \\
\t2 i\_att\_group\_cardinality~ss~att.card~expr\_interp)
\also
   \ELSE \IF att.opValue \in \ran attrib\_num  \THEN \\
\t1 (\LET num\_interp == \\
\t1 i\_numericComparisonOperator~ss~att.rf~(result\_sctids~att\_sctids)~(attrib\_num \inv att.opValue)  @ \\
\t2 i\_att\_group\_cardinality~ss~att.card~num\_interp)
\also
   \ELSE  \\
\t1 (\LET str\_interp == \\
\t1 i\_stringComparisonOperator~ss~att.rf~(result\_sctids~att\_sctids)~(attrib\_str \inv att.opValue)  @ \\
\t2 i\_att\_group\_cardinality~ss~att.card~str\_interp))
\end{axdef}

\subsubsection{cardinality inside a group}

Cardinality is interpreted differently within the context of a a group.  In particular:
\begin{itemize}[noitemsep]
\item Zero groups are treated as ``singletons'' -- every quad with a zero group is treated as a group unto itself.
\item A sctid can pass in the context of more than one group.  Intersections, unions, etc. apply to sctid's in the \emph{same} group.
\end{itemize}

$i\_att\_group\_cardinality$ takes an optional cardinality and a set of quads and returns a list sctids and the corresponding groups in which they passed the cardinality constraint.  Note that, in the case
of the zero group, the actual $Quad$ that passed is associated with the sctid rather than the group identifier itself.

\begin{axdef}
   i\_att\_group\_cardinality : \\
\t1 Substrate \fun \optional[cardinality] \fun Quads\_or\_Error \fun sctIdGroups\_or\_Error
\where
   \forall ss:Substrate; ocard : \optional[cardinality]; qore : Quads\_or\_Error @ \\
   i\_att\_group\_cardinality~ss~ocard~qore = \\
\IF qore \in \ran qerror \THEN \\
\t1 gerror (qerror \inv qore) 
\also
\ELSE \IF \# ocard = 0 \THEN \\
\t1 group\_value~(i\_required\_att\_group\_cardinality~1~many~qore)
\also
\ELSE (\LET card == head~ocard @ \\
\t1 \IF card.min > 0 \THEN \\
\t1 group\_value~(i\_required\_att\_group\_cardinality~card.min~card.max~qore)
\also
\ELSE \\
\t1 group\_value~(i\_optional\_att\_group\_cardinality~ss~card.max~qore))
\end{axdef}

\noindent
$i\_required\_att\_group\_cardinality$ returns the set of subject or target sctids combined with the group(s) (or $Quads$) in which they qualified
\begin{axdef}
   i\_required\_att\_group\_cardinality : \\
\t1 \nat \fun unlimitedNat \fun Quads\_or\_Error \ \fun \power sctIdGroup
\where
   \forall min : \nat; max : unlimitedNat; qore : Quads\_or\_Error  @ \\
i\_required\_att\_group\_cardinality~min~max~qore = \\
\IF quad\_direction~qore = source\_direction \THEN \\
\t1 \{subjgroup :  \{q : quads\_for~qore | q.g \neq zero\_group @ (q.s, quadGroup~ q) \} | \\
\t2 evalCardinality[Quad]~min~max~ \{q : quads\_for~qore | \\
\t3 q.s = first~subjgroup \land q.g = (ug \inv (second~subjgroup))\} \neq \emptyset \}  \\
\t4 \cup \\
\t1 \{q : quads\_for~qore | q.g = zero\_group \land  \\
\t2 evalCardinality[Quad]~min~max~\{q\} \neq \emptyset @ (q.s, quadGroup~ q) \} \\
\also
\ELSE \\
\t1 \{targgroup :  \{q : quads\_for~qore | \\
\t2 q.g \neq zero\_group \land q.t \in \ran t\_sctid @ (t\_sctid \inv q.t, quadGroup~ q) \} | \\
\t2 evalCardinality[Quad]~min~max~ \{q : quads\_for~qore | \\
\t3 t\_sctid \inv q.t = first~targgroup \land \\
\t3 q.g = (ug \inv (second~targgroup))\} \neq \emptyset \} \\
\t4 \cup \\
\t1 \{q : quads\_for~qore | q.g = zero\_group \land  \\
\t2 evalCardinality[Quad]~min~max~\{q\} \neq \emptyset @ (t\_sctid \inv q.t, quadGroup~ q) \} \\
\end{axdef}

\noindent
$i\_optional\_att\_group\_cardinality$ returns the set of subject or target sctids along with all of the corresponding groups that \emph{fail} the cardinality test.  The failing list
is equivalent to the set of all possible sctid / non-zero groups in the substrate minus the set of sctid / non-zero groups that fail the maximum cardinality. The set of failures is determined by removing the set of passing tuples from the total possible set in the supplied quads.
\begin{axdef}
   i\_optional\_att\_group\_cardinality : \\
\t1 Substrate \fun unlimitedNat \fun Quads\_or\_Error \ \fun \power sctIdGroup
\where
   \forall ss:Substrate; max : unlimitedNat; qore : Quads\_or\_Error  @ \\
i\_optional\_att\_group\_cardinality~ss~max~qore = \\
\IF quad\_direction~qore = source\_direction \THEN \\
\t1  (\{rel: ss.relationships @ (rel.s, quadGroup~rel) \}~  \setminus \\
\t1 \{q : quads\_for~qore @ (q.s, quadGroup~q) \} )~ ~  \cup \\
\t2 i\_required\_att\_group\_cardinality~0~max~qore
\also
\ELSE \\
\t1  (\{rel: ss.relationships | rel.t \in \ran t\_sctid @ (t\_sctid \inv rel.t, quadGroup~rel) \}~  \setminus \\
\t1 \{q : quads\_for~qore | q.g \neq zero\_group @ (t\_sctid \inv q.t , quadGroup~q) \})~ ~  \cup \\
\t2 i\_required\_att\_group\_cardinality~0~max~qore
\end{axdef}


% =========================================== Section 4 ===============================================

\section{Substrate Interpretations}
\label{sect:substrate}
This section defines the interpretations that are realized against the substrate. 

\subsection{constraintOperator}
\begin{framed}
\desc{A constraint operator is either 'descendantOrSelfOf', 'descendantOf', 'ancestorOrSelfOf', or 'ancestorOf'.}
\end{framed}

\begin{framed}
\noindent
\bnf{constraintOperator = descendantOrSelfOf / descendantOf /  ancestorOrSelfOf / ancestorOf}
\end{framed}

The interpretation of $\optional[constraintOperator]$ is one of:
\begin{itemize}[noitemsep]
\item The input if an operator isn't supplied or if it contains an error
\item The union  of descendants of all members of the input, as provided by the substrate if the operator is $descendantOf$
\item The union of descendants \underline{plus} the input if the operator is $descendantOrSelfOf$
\item The union  of ancestors of all members of the input, as provided by the substrate if the operator is $ancestorOf$ 
\item The union of ancestors \underline{plus} the input if the operator is $ancestorsOrSelfOf$
\end{itemize}

Note that it is possible for some or all of the members of the input to be included in the $descendantOf$ or $ancestorOf$ operations as
the descendants of one input sctid may include another input sctid.

The $completeFun$ function assures that an operation on any identifier that isn't in the domain of the substrate $descendants$ or $ancestors$ function 
returns the empty set ($\emptyset$).

\begin{zed}
constraintOperator ::= \\ 
\t2 descendantOrSelfOf | descendantOf | ancestorOrSelfOf | ancestorOf
\end{zed}


\begin{axdef}
   i\_constraintOperator : \\
\t1 Substrate \fun \optional[constraintOperator] \fun Sctids\_or\_Error \fun Sctids\_or\_Error
\also
   completeFun : (sctId \pfun \power sctId) \fun sctId \fun \power sctId \\
\where
	\forall ss : Substrate; oco : \optional[constraintOperator]; input : Sctids\_or\_Error @ \\
i\_constraintOperator~ss~oco~input = \\
\t1 \IF error \inv input \in ERROR \lor \# oco = 0  \THEN  \\
\t2 input \\
\t1 \ELSE \IF head~oco = descendantOrSelfOf \THEN \\
\t2 ok (\bigcup \{id : result\_sctids~input @ \\
\t3 completeFun~ss.descendants~id \} \cup result\_sctids~input) \\
\t1 \ELSE \IF head~oco = descendantOf~ \THEN \\
\t2 ok  (\bigcup \{id : result\_sctids~input @ \\
\t3 completeFun~ss.descendants~id ~\}) \\
\t1 \ELSE \IF head~oco = ancestorOrSelfOf~ \THEN  \\
\t2 ok (\bigcup \{id : result\_sctids~input @ \\
\t3 completeFun~ss.ancestors~id \} \cup result\_sctids~input) \\
\t1 \ELSE  \\
\t2 ok (\bigcup \{id : result\_sctids~input \\
\t3 @ completeFun~ ss.ancestors~id ~\}) \\
\also
   \forall f : (sctId \pfun \power sctId); id : sctId @ completeFun~f~id = \\
\t1\IF id \in \dom f \THEN f~id \ELSE \emptyset 
\end{axdef}

\subsection{attributeOperator}
\begin{framed}
\desc{An attribute operator indicates that instead of just matching the named attribute with the given attribute value, any descendants of or any descendants or self of the named attribute may match the given attribute value.}
\end{framed}
\begin{framed}
\bnf{attributeOperator = descendantOrSelfOf / descendantOf}
\end{framed}

The interpretation of $attributeOperator$ is the same as the interpretation of $constraintOperator$

\begin{zed}
attributeOperator == constraintOperator \\
i\_attributeOperator == i\_constraintOperator
\end{zed}

\subsection{expressionComparisonOperator}
\begin{framed}
\desc{Attributes whose value is a concept may be compared to an expression constraint using either equals (``='') or not equals (``!=''). In the full syntax ``\textless\textgreater'' and ``not ='' (case insensitive) are also  valid ways to represent not equals.}
\end{framed}

\begin{framed}
\noindent
\bnf{expressionComparisonOperator = ``='' / ``!=''}
\end{framed}

The interpretation of \spec{expressionComparisonOperator} is the set of all quads in the substrate having a target (or subject if the direction is reverse) that are (or are not) in
the interpretation of the \spec{expressionConstraintValue}


\begin{zed}
expressionComparisonOperator ::= eco\_eq | eco\_neq
\end{zed}

\begin{axdef}
   i\_expressionComparisonOperator: \\
\t1 Substrate \fun \optional[reverseFlag] \fun \power sctId \fun \\
\t1 (expressionComparisonOperator \cross expressionConstraintValue) \fun Quads\_or\_Error
\where
    \forall ss : Substrate; rf : \optional[reverseFlag]; atts : \power sctId; \\
\t1 ec : (expressionComparisonOperator \cross expressionConstraintValue)  @ \\
    i\_expressionComparisonOperator~ss~rf~atts~ec = \\
    (\LET ecv == i\_expressionConstraintValue~ss~(second~ec) @ \\
\t1 \IF ecv \in \ran error \THEN \\
\t2 qerror(error \inv ecv) \\
\t1 \ELSE \IF \# reverseFlag = 0 \land (first~ec =  eco\_eq) \THEN \\
\t2 quad\_value( \{q : ss.relationships | \\
\t3 q.t \in \ran t\_sctid \land (t\_sctid \inv q.t) \in (result\_sctids~ecv) \}, source\_direction) \\
\t1 \ELSE \IF \# reverseFlag > 0  \land (first~ec =  eco\_eq) \THEN \\
\t2 quad\_value(\{q : ss.relationships | \\
\t3 q.s \in (result\_sctids~ecv) \} , targets\_direction) \\
\t1  \ELSE \IF \# reverseFlag = 0  \land (first~ec =  eco\_neq) \THEN \\
\t2 quad\_value( \{q : ss.relationships | \\
\t3 q.t \in \ran t\_sctid \land (t\_sctid \inv q.t) \notin (result\_sctids~ecv) \}, source\_direction) \\
\t1 \ELSE \\
\t2 quad\_value ( \{q : ss.relationships | \\
\t3 q.s \notin (result\_sctids~ecv) \}, targets\_direction) )
 \end{axdef}
 
 \subsection{numericComparisonOperator}
\begin{framed}
\desc{Attributes whose value is numeric (i.e. integer or decimal) may be compared to a specific concrete value using a variety of comparison operators, including equals (``=''), less than (``\textless''), less than or equals (``\textless=''), greater than (``\textgreater''), greater than or equals (``\textgreater='') and not equals (``!=''). In the full syntax ``\textless\textgreater'' and ``not ='' (case insensitive) are also valid ways to represent not equals.}
\end{framed}

\begin{framed}
\noindent
\bnf{numericComparisonOperator = ``='' / ``!='' / ``\textless='' / ``\textless'' / ``\textgreater='' / ``\textgreater''}
\end{framed}

The interpretation of \spec{numericComparisonOperator} is the set of all quads in the substrate having a  $concreteValue$ target of type $cv\_integer$ or $cv\_decimal$ that (or do not meet) the supplied 
criteria. As concrete values cannot occur as subjects, this function returns the empty set if the reverse flag is supplied


\begin{zed}
numericComparisonOperator ::= nco\_eq | nco\_neq | nco\_gt | nco\_ge | nco\_lt | nco\_le
\end{zed}

\begin{axdef}
   i\_numericComparisonOperator: \\
\t1 Substrate \fun  \optional[reverseFlag] \fun \power sctId \fun \\
\t1 (numericComparisonOperator \cross numericValue) \fun Quads\_or\_Error
\where
    \forall ss : Substrate; rf : \optional[reverseFlag]; atts : \power sctId; \\
\t1 ncv : (numericComparisonOperator \cross numericValue)  @ \\
    i\_numericComparisonOperator~ss~rf~atts~ncv = \\
\IF \# rf > 0 \THEN \\
\t1 quad\_value(\emptyset, targets\_direction) \\
\ELSE \\
\t1 quad\_value( \{q : ss.relationships | q.a \in atts \land q.t \in \ran t\_concrete \land  \\
numericComparison~(t\_concrete \inv q.t)~(first~ncv) = (second~ncv) \}, source\_direction)
 \end{axdef}
 
 Numeric comparison function. Compares a $concreteValue$ with a $numericValue$.
 \paragraph{}
 \textbf{TODO:} Need to specify the rules for comparing integers and decimal numbers as well as decimal/decimal.  As an example, does ``5.00'' = ``5.0''
 \begin{axdef}
    numericComparison: \\
\t1 concreteValue \fun numericComparisonOperator \pfun numericValue
 \end{axdef}
 
\subsection{stringComparisonOperator}
\begin{framed}
\desc{Attributes whose value is numeric may be compared to an expression constraint using either equals (``='') or not equals (``!=''). In the full syntax ``<>'' and ``not ='' (case insensitive) are also  valid ways to represent not equals.}
\end{framed}

\begin{framed}
\noindent
\bnf{stringComparisonOperator = ``='' / ``!=''}
\end{framed}


\begin{zed}
stringComparisonOperator ::= sco\_eq | sco\_neq
\end{zed}

\begin{axdef}
   i\_stringComparisonOperator: \\
\t1 Substrate \fun  \optional[reverseFlag] \fun \power sctId \fun \\
\t1 (stringComparisonOperator \cross stringValue) \fun Quads\_or\_Error
\where
    \forall ss : Substrate; rf : \optional[reverseFlag]; atts : \power sctId; \\
\t1 scv : (stringComparisonOperator \cross stringValue)  @ \\
    i\_stringComparisonOperator~ss~rf~atts~scv = \\
\IF \# rf > 0 \THEN \\
\t1 quad\_value(\emptyset, targets\_direction) \\
\ELSE \\
\t1 quad\_value( \{q : ss.relationships | q.a \in atts \land q.t \in \ran t\_concrete \land \\
stringComparison~(t\_concrete \inv q.t)~(first~scv) = (second~scv) \}, source\_direction)
 \end{axdef}


 String comparison function. Compares a $concreteValue$ with a $stringValue$.
 \begin{axdef}
    stringComparison: \\
\t1 concreteValue \fun stringComparisonOperator \pfun stringValue
 \end{axdef}





\subsection{focusConcept}
\begin{framed}
\desc{A focus concept is a concept reference or wild card, which is optionally preceded by a member of function. A memberOf function should be used only when the conceptReference refers to a reference set concept, or a wild card is used.}
\desc{A wild card represents any concept in the given substrate. In the brief syntax, a wildcard is represented using the ``*'' symbol. In the full syntax, the text ``ANY'' (case insensitive) is also allowed.}
\end{framed}

\begin{framed}
\bnf{focusConcept = [ memberOf ws] (conceptReference / wildCard)} 
\end{framed}

\begin{zed}
crOrWildCard ::= cr \ldata conceptReference \rdata | wc  \\
focusConcept ::= \\
\t1 focusConcept\_m \ldata crOrWildCard \rdata | \\
\t1 focusConcept\_c \ldata crOrWildCard \rdata
\end{zed}


\textbf{Interpretation:}  If  \spec{memberOf} is present the interpretation of  \spec{focusConcept} is union the interpretation of \spec{memberOf} applied to
each element in the interpretation of \spec{conceptReference}.  Note that the interpretation of \spec{wildCard} is different in the context of \spec{memberOf} than
it is outside.  \spec{memberOf wildCard} is interpreted as the interpretation of the domain of the $refset$ function (i.e. all of the refsets in the substrate), where, without,
it is interpreted as \emph{all} of the concepts in the system.

  If \spec{memberOf} isn't specified, the interpretation is the substrate interpretations of \spec{conceptReference} itself

\begin{axdef}
   i\_focusConcept : Substrate \fun focusConcept \fun Sctids\_or\_Error 
\where
   \forall ss : Substrate; fc : focusConcept @ \\
i\_focusConcept~ss~fc = \\
\IF focusConcept\_c \inv fc \in crOrWildCard \THEN \\
\t1 \IF cr \inv (focusConcept\_c \inv fc) \in conceptReference \THEN \\
\t2 ss.i\_conceptReference~(cr \inv (focusConcept\_c \inv fc)) \\
\t1 \ELSE \\
\t2 ok~ss.concepts \\
 \ELSE \\
\t1  i\_memberOf~ss~(focusConcept\_m~\inv fc)
\end{axdef}

\subsubsection{memberOf}
\spec{memberOf} returns the union of the application of the substrate $refset$ function to a wild card or the  the supplied reference set identifiers.  An error is
returned if (a) $refsetids$ already has an error or (b) the substrate interpretation of a given refsetId returns an error.

\begin{axdef}
   i\_memberOf : Substrate \fun crOrWildCard \fun Sctids\_or\_Error 
\where
   \forall ss : Substrate; crorwc : crOrWildCard @ \\
   \t1 i\_memberOf~ss~crorwc= \\
(\LET refsetids == \\
\t1 \IF cr \inv crorwc \in conceptReference \\
\t1 \THEN \\
\t2 ss.i\_conceptReference(cr \inv crorwc) \\
\t1 \ELSE \\
\t2 ok~(ss.descendants~refset\_concept) @ \\
\t1 \IF refsetids \in \ran error \\
\t1 \THEN \\
\t2 refsetids \\
\t1 \ELSE \\
\t2 bigunion \{sctid: result\_sctids~refsetids @ ss.i\_refsetId~sctid \} )
\end{axdef}

\pagebreak

\section{Types}
This section carries various type transformations and error checking functions

\subsection{Types}

\subsubsection{Quads\_or\_Error}
$Quads\_or\_Error$ is a collection of $Quad$s or an error condition.  If it is a collection of $Quad$s, it also carries a direction indicator that determines
whether it is the source or targets that carry the matching elements.   Note:
\begin{itemize}[noitemsep,nolistsep]
\item \textbf{$source\_direction$} -- matches were performed on attribute/target. Return the source $sctId$s.
\item \textbf{$targets\_direction$} -- matches were performed on attribute/source (\spec{reverseFlag} was present).  Return the target $sctId$s or, eventually, concrete values
\end{itemize}

\begin{zed}
direction ::= source\_direction | targets\_direction \\
Quads\_or\_Error ::= quad\_value \ldata \power Quad \cross direction \rdata | qerror \ldata ERROR \rdata
\end{zed}

\subsubsection{sctIdGroups}
The $groupId$ identifies a set of one or more quads associated with the same subject.  The zero group, however, is treated differently,
where each individual quad is treated as a group unto itself.  To implement this, we have to assign some sort of reproducible secondary "group" identifier to zero
groups.  While actual implementations will probably use a secondary identifier such as the RF2 relationship sctid, for the purposes of this specification we use
the quad itself as the unique identity of the "group".  This is represented by the $uniqueGroupId$ construct below:

\begin{zed}
uniqueGroupId ::= ug \ldata groupId \rdata  | zg \ldata Quad \rdata
\end{zed}


The $sctidGroup$ represents a subject or target $sctid$s that meet the requirements of an attribute or attribute set within the context of a group.  Each $sctidGroup$ entry carries
with the $sctid$ that passed along with the group identifier of the group in which it passed, or the whole Quad in the case of zero groups.of the specific group in which it passed. The $sctidGroup$ construct
is used for unions, intersections and differences within the context of a specific group. \\

\noindent
$sctIdGroups\_or\_Error$ represents a set of $sctIdGroups$ or an error condition

\begin{zed}
sctIdGroup == sctId \cross uniqueGroupId \\
sctIdGroups\_or\_Error ::= group\_value \ldata \power sctIdGroup \rdata | \\
\t2 gerror \ldata ERROR \rdata
\end{zed}

The $quadGroup$ function converts a $Quad$ to a corresponding $uniqueGroupId$, where the result is the $groupId$ of the quad if the group is non-zero, and the quad itself
when the group is zero.

\begin{axdef}
quadGroup : Quad \fun uniqueGroupId \\
\where 
\forall q: Quad @ quadGroup~q =  \\
\t1 \IF q.g \neq zero\_group \THEN \\
\t2 ug~q.g \\
\t1 \ELSE \\
\t2 zg~q 
\end{axdef}


\subsection{Result transformations}
\begin{itemize}[noitemsep,nolistsep]
\item \textbf{result\_sctids} -- the set of $sctId$s in $Sctids\_or\_Error$ or the empty set if there is an error
\item \textbf{quads\_for} -- the set of quads in a $Quads\_or\_Error$ or an empty set if there is an error
\item \textbf{quad\_direction} -- the direction of a $Quads\_or\_Error$ result.  Undefined if error
\end{itemize}
\begin{axdef}
   result\_sctids: Sctids\_or\_Error \fun \power sctId \\
   quads\_for: Quads\_or\_Error \fun \power Quad  \\
   quad\_direction: Quads\_or\_Error \pfun direction \\
\where
   \forall r: Sctids\_or\_Error @ result\_sctids~r = \\
\t1 \IF r \in \ran error \THEN \emptyset \\
\t1 \ELSE ok \inv r
\also
   \forall q : Quads\_or\_Error @ quads\_for~q = \\
\t1 \IF q \in \ran qerror  \THEN \emptyset \\
\t1 \ELSE first~(quad\_value \inv q)
\also
   \forall q : Quads\_or\_Error @ quad\_direction~q = \\
\t1 second~(quad\_value \inv q)
\end{axdef}



\paragraph{}
Definition of the various functions that are performed on the result type. \\
\begin{itemize}[noitemsep,nolistsep]
\item \textbf{firstError} -- aggregate one or more $Sctids\_or\_Error$ types, at least one of which carries and error and merge them into a single $Sctid\_or\_Error$ instance propagating at least one of the errors (Not fully defined)
\item \textbf{gfirstError} -- convert two $sctIdGroups\_or\_Error$ into a single $sctIdGroups\_or\_Error$ propagating at least one of the errors.
\end{itemize}

\begin{itemize}[noitemsep]
\item \textbf{union} -- return the union of two $Sctids\_or\_Error$ types, propagating errors if they exist, else returning the union of the sctId sets.
\item \textbf{intersect} --return the intersection of two $Sctids\_or\_Error$ types, propagating errors if they exist, else returning the intersection of the sctId sets.
\item \textbf{minus} -- return the difference of one $Sctids\_or\_Error$ type and a second, propagating errors if they exist, else returning the set of sctId's in the first set that aren't in the second. 
\item \textbf{bigunion} -- return the union of a set of $Sctids\_or\_Error$ types, propagating errors if they exist, else returning the union of  all of the sctId sets.
\item \textbf{bigintersect} -- return the intersection a set of $Sctids\_or\_Error$ types, propagating errors if they exist, else returning the intersection of all of  the sctId sets.
\end{itemize}

\begin{axdef}
   firstError : \power Sctids\_or\_Error \fun Sctids\_or\_Error \\
   gfirstError : \power sctIdGroups\_or\_Error \fun sctIdGroups\_or\_Error
\also
   union, intersect, minus : Sctids\_or\_Error \fun Sctids\_or\_Error \fun \\
\t2 Sctids\_or\_Error \\
   bigunion, bigintersect : \power Sctids\_or\_Error \fun Sctids\_or\_Error \\
\also
   gunion, gintersect, gminus : \\
   \t1 sctIdGroups\_or\_Error \fun sctIdGroups\_or\_Error \fun sctIdGroups\_or\_Error
\where
   \forall x,y : Sctids\_or\_Error @ union~x~y = \\
\t1 \IF x \in \ran error \lor  y \in \ran error \THEN firstError~\{x, y\} \\
\t1 \ELSE ok~((ok \inv x) \cup (ok \inv y))
\also
   \forall x,y : Sctids\_or\_Error @ intersect~x~y = \\
\t1 \IF x \in \ran error \lor y \in \ran error \THEN firstError~\{x, y\} \\
\t1 \ELSE ok~((ok \inv x) \cap (ok \inv y))
\also
   \forall x,y : Sctids\_or\_Error @ minus~x~y = \\
\t1 \IF x \in \ran error \lor y \in \ran error \THEN firstError~\{x, y\} \\
\t1 \ELSE ok~((ok \inv x) \setminus (ok \inv y))
\also
  \forall rs : \power Sctids\_or\_Error @ bigunion~rs = \\
\t1 \IF \exists r : rs @ r \in \ran error \THEN firstError~ rs \\
\t1 \ELSE ok~(\bigcup \{r : rs @ result\_sctids~r\})
\also
  \forall rs : \power Sctids\_or\_Error @ bigintersect~rs = \\
\t1 \IF \exists r : rs @ r \in \ran error \THEN firstError~ rs \\
\t1 \ELSE ok~(\bigcap \{r : rs @ result\_sctids~r\})
\also
   \forall x,y : sctIdGroups\_or\_Error @ gintersect~x~y = \\
\t1 \IF x \in \ran gerror \lor y \in \ran gerror \THEN gfirstError~\{x, y\} \\
\t1 \ELSE group\_value((group\_value \inv x) \cap (group\_value \inv y))
\also
\forall x,y : sctIdGroups\_or\_Error @ gunion~x~y = \\
\t1 \IF x \in \ran gerror \lor y \in \ran gerror \THEN gfirstError~\{x, y\} \\
\t1 \ELSE group\_value((group\_value \inv x) \cup (group\_value \inv y))
\also
\forall x,y : sctIdGroups\_or\_Error @ gminus~x~y = \\
\t1 \IF x \in \ran gerror \lor y \in \ran gerror \THEN gfirstError~\{x, y\} \\
\t1 \ELSE group\_value((group\_value \inv x) \setminus (group\_value \inv y))
\end{axdef}
\pagebreak
\appendix
   

\section{Optional elements}
Representing optional elements of type $T$.  Representing it as a sequence allows us to
determine absence by $\#T = 0$ and the value by $head~T$. 

\begin{zed} 
  \optional[T] == \{ s : \seq T \mid \# s \leq 1 \} 
\end{zed}

\section{Generic cardinality evaluation}
\paragraph{evalCardinality}
Evaluate the cardinality of an arbitrary set of type $T$.  If the number of elements in the set of $T$ is greater than $min$ and:
\begin{itemize}[noitemsep]
\item $max$ is a number and the number of elements in $T$ is less than $max$
\item $max$ is $many$
\end{itemize}
Then return the the set.  Otherwise return the empty set.

\begin{gendef}[T]
   evalCardinality : \nat \fun unlimitedNat \fun \power T \fun \power T
\where
   \forall min : \nat; max : unlimitedNat; t : \power T @ \\
evalCardinality~min~max~t = \\
\t1 \IF (\#t \geq min) \land (max = many \lor \#t \leq (num \inv max) ) \\
\t1 \THEN \\
\t2 t \\
\t1 \ELSE  \\
\t2 \emptyset
\end{gendef}

\section{Generic sequence function}
A generic function that takes:
\begin{itemize}[noitemsep]
\item A substrate
\item A function that takes a substrate, a sequence of type $T$ and returns $Sctids\_or\_Error$  (example: $i\_subExpressionConstraint$)
\item An operator that takes two $Sctids\_or\_Error$ and returns a combination (example: $union$)
\item A tuple of the form ``$T \cross \seq_1 T$''
\end{itemize}

And returns $Sctids\_or\_Error$
\paragraph{}
In the formalization below, $first ~seq\_e$ refers to the left hand side of the $T \cross \seq_1 T$ and
$second ~seq\_e$ to the right hand side.  $head (second~seq\_e)$ refers to the first element in the sequence and 
$tail (second~seq\_e)$ refers to the remaining elements in the sequence, which may be empty ($\langle \rangle$).

\begin{gendef}[T]
    applyToSequence : Substrate \fun (Substrate \fun T \fun Sctids\_or\_Error) \fun \\
\t1 (Sctids\_or\_Error \fun Sctids\_or\_Error \fun Sctids\_or\_Error) \fun \\
\t1 (T \cross \seq_1 T) \fun Sctids\_or\_Error
\where
   \forall ss : Substrate;  f: (Substrate \fun T \fun Sctids\_or\_Error); \\
\t1 op: (Sctids\_or\_Error \fun Sctids\_or\_Error \fun Sctids\_or\_Error); \\ 
\t1 seq\_e:  (T \cross \seq_1 T) @ \\
applyToSequence~ss~f~op~seq\_e = \\
   \IF tail(second~seq\_e) = \langle \rangle \THEN \\
\t1 op~(f~ss~(first~seq\_e)) (f~ss~(head~(second~seq\_e))) \\
   \ELSE \\
\t1 op~(f~ss~(first~seq\_e)) (applyToSequence~ss~f~op~(head~(second~seq\_e), tail~(second~seq\_e)))
\end{gendef}
   

\end{document}


   

